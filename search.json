[
  {
    "objectID": "reticulate/NEWS.html",
    "href": "reticulate/NEWS.html",
    "title": "reticulate 1.36.0",
    "section": "",
    "text": "Internal refactoring and optimization now give a faster experience, especially for workflows that frequently access Python objects from R. For example, simple attribute access like sys$path is ~2.5x times faster, and a sample workload of py_to_r(np_array(1:3) + np_array(1:3)) benchmarks ~3.5x faster when compared to the previous CRAN release.\nFixed issue where callable python objects created with convert = FALSE would not be wrapped in an R function (#1522).\nFixed issue where py_to_r() S3 methods would not be called on arguments supplied to R functions being called from Python (#1522).\ninstall_python() will now build optimized versions of Python on macOS and Linux (#1567)\nDefault Python version installed by install_python() is now 3.10 (was 3.9) (#1574).\nOutput of reticulate::py_last_error() now includes a hint, showing how to access the full R call stack (#1572).\nFixed an issue where nested py_capture_output() calls result in a lost reference to the original sys.stdout and sys.stderr, resulting in no further visible output from Python, and eventually, a segfault. (#1564)\nFixed issues reported by rchk, as requested by CRAN (#1581).\npy_to_r(x) now returns x unmodified if x is not a Python object, instead of signaling an error.\nNew as.data.frame() method exported for Python Polars DataFrames (#1568)\nFixed an issue where printing a delayed module (import(\"foo\", delay_load = TRUE)) would output &lt;pointer: 0x0&gt;.\npy_validate_xptr() will now attempt to resolve delayed modules before signaling an error (#1561).\nR packages can now express multiple preferred Python environments to search for and use if they exist, by supplying a character vector to import(): import(\"foo\", delay_load = list(environment = c(\"r-foo\", \"r-bar\"))) (#1559)\nReticulate will no longer warn about ignored use_python(,required = FALSE) calls (#1562).\nreticulate now prefers using the agg matplotlib backend when the R session is non-interactive. The backend can also be overridden via the MPLBACKEND or RETICULATE_MPLBACKEND environment variables when necessary (#1556).\nattr(x, \"tzone\") attributes are (better) preserved when converting POSIXt to Python. POSIXt types with a non-empty tzone attr convert to a datetime.datetime, otherwise they convert to NumPy datetime64[ns] arrays.\nFixed an issue where calling py_set_item() on a subclassed dict would not invoke a custom __setitem__ method.\npy_del_attr(x, name) now returns x invisibly\nsource_python() no longer exports the r symbol to the R global environment. (the “R Interface Object” that is used by Python code get a reference to the R globalenv())\nFixed hang encountered (sometimes) when attempting to call iterate() on an exhausted py_iterator() object multiple times (#1539).\niterate(simplify=TRUE) rewritten in C for speed improvements (#1539).\nUpdate for Pandas 2.2 deprecation of Index.format() (#1537, #1538).\nUpdates for CRAN R-devel (R 4.4) (#1554).\nFixed an issue where py_discover_config() would discover python (v2) on the PATH in preference of python3 on the PATH. (#1547)\nFixed an issue where reticulate would error when using conda environments created with the (new) conda env create command. (#1535, #1543)\nFixed an issue where reticulate would error when using a conda environment where the original conda binary that was used to create the environment is no longer available (#1555)\nFixed an issue where a user would be unable to accept the prompt to create the default “r-reticulate” venv (#1557).\nis_py_object() is now exported (#1573)."
  },
  {
    "objectID": "reticulate/NEWS.html#knitr-python-engine-changes",
    "href": "reticulate/NEWS.html#knitr-python-engine-changes",
    "title": "reticulate 1.36.0",
    "section": "Knitr Python Engine Changes:",
    "text": "Knitr Python Engine Changes:\n\nThe knitr python engine now formats captured python exceptions to include the exception type and any exception notes when chunk options error = TRUE is set (reported in #1520, fixed in #1527).\nFixed an issue where the knitr python engine would fail to include figures from python chunks if a custom root.dir chunk option was set. (reported in #1526, fixed in #1529)\nknitr engine gains the ability to save chunk figures in multiple files/formats (Contributed by @Rumengol in #1507)\nFixed an issue where matplotlib figures generated in the initial chunk where matplotlib was first imported would be the wrong size (reported in #1523, fixed in #1530)\nFixed an issue where the knitr engine would not correctly display altair compound charts if more than one were present in a document (#1500, #1532)."
  },
  {
    "objectID": "reticulate/NEWS.html#python-installation-management",
    "href": "reticulate/NEWS.html#python-installation-management",
    "title": "reticulate 1.36.0",
    "section": "Python Installation Management",
    "text": "Python Installation Management\n\nreticulate will no longer prompt users to install miniconda. Instead, reticulate will now prompt users to create a default r-reticulate venv.\nThe search that reticulate conducts to select which Python installation to load has changed. See the updated Python “Order of Discover” in the “versions” vignette. vignette(\"versions\", package = \"reticulate\").\nUpdated recommendations in the “python_dependencies” vignette for how R packages can approach Python dependency management. vignette(\"python_dependencies\", package = \"reticulate\")\nNew function virtualenv_starter(), which can be used to find a suitable python binary for creating a virtual environment. This is now the default method for finding the python binary when calling virtualenv_create(version = &lt;version&gt;).\nvirtualenv_create() and virtualenv_install() gain a requirements argument, accepting a filepath to a python requirements file.\nvirtualenv_create() gains a force argument.\nvirtualenv_install() gains a python_version argument, allowing users to customize which python version is used when bootstrapping a new virtual environment.\nFixed an issue where the list of available python versions used by install_python() would be out-of-date.\ninstall_python() now gives a better error message if git is not installed.\ninstall_python() on macOS will now will use brew, if it’s available, to install build dependencies, substantially speeding up python build times.\nNew function conda_search(), contributed by @mkoohafkan in PR #1364."
  },
  {
    "objectID": "reticulate/NEWS.html#language",
    "href": "reticulate/NEWS.html#language",
    "title": "reticulate 1.36.0",
    "section": "Language",
    "text": "Language\n\nNew [ and [&lt;- methods that invoke Python __getitem__, __setitem__ and __delitem__. The R generics [ and [&lt;- now accept python-style slice syntax like x[1:2:3]. See examples in ?py_get_item.\npy_iterator() gains a prefetch argument, primarily to avoid deadlocks where the main thread is blocked, waiting for the iterator, which is waiting to run on the main thread, as encountered in TensorFlow/Keras. (#1405).\nString columns from Pandas data frames containing None, pd.NA or np.nan are now simplified into character vectors and missing values replaced by NA (#1428).\nConverting from Pandas data frames containing columns with Pandas nullable data types are now correctly converted into R data.frames preserving the missing values (#1427)."
  },
  {
    "objectID": "reticulate/NEWS.html#knitr",
    "href": "reticulate/NEWS.html#knitr",
    "title": "reticulate 1.36.0",
    "section": "Knitr",
    "text": "Knitr\n\nThe knitr engine gains a jupyter_compat option, enabling reticulate to better match the behavior of Jupyter. When this chunk option is set to TRUE, only the return value from the last expression in a chunk is auto-printed. (#1391, #1394, contributed by @matthew-brett)\nThe knitr engine now more reliably detects and displays matplotlib pending plots, without the need for a matplotlib artist object to be returned as a top-level expression. E.g., the knitr engine will now display plots when the matplotlib api returns something other than an artist object, (plt.bar()), or the matplotlib return value is not auto-printed due to being assigned, (x = plt.plot()), or suppressed with a ;, (plt.plot();). (#1391, #1401, contributed by @matthew-brett)\nFixed an issue where knitr engine would not respect chunk options fig.width / fig.height when rendering matplotlib plots. (#1398)\nFixed an issue where the reticulate knitr engine would not capture output printed from python. (PR #1412, fixing #1378, #331)"
  },
  {
    "objectID": "reticulate/NEWS.html#miscellanous",
    "href": "reticulate/NEWS.html#miscellanous",
    "title": "reticulate 1.36.0",
    "section": "Miscellanous",
    "text": "Miscellanous\n\nReticulate now periodically flushes python stdout and stderr buffers even while the main thread is blocked executing Python code. Streaming output from a long-running Python function call will now appear in the R console while the Python function is still executing. (Previously, output might not appear until the Python function had finished and control of the main thread had returned to R).\nUpdated sparse matrix conversion routines for compatibility with scipy 1.11.0.\nFixed an issue where a py capsule finalizer could access the R API from a background thread. (#1406)\nFixed issue where R would segfault (crash) in long-lived R sessions where both rpy2 and reticulate were in use (#1236).\nFixed an issue where exceptions from reticulate would not be formatted properly when running tests under testthat (r-lib/rlang#1637, #1413).\nFixed an issue where py_get_attr(silent = TRUE) would not return an R NULL, if the attribute was missing, as documented. (#1413)\nFixed an issue where py_get_attr(silent = TRUE) would leave a python global exception set if the attribute was missing, resulting in fatal errors when running python under debug mode. (#1396)"
  },
  {
    "objectID": "reticulate/doc/r_markdown.html",
    "href": "reticulate/doc/r_markdown.html",
    "title": "R Markdown Python Engine",
    "section": "",
    "text": "The reticulate package includes a Python engine for R Markdown that enables easy interoperability between Python and R chunks.\nPython chunks behave very similar to R chunks (including graphical output from matplotlib) and the two languages have full access each other’s objects. Built in conversion for many Python object types is provided, including NumPy arrays and Pandas data frames.\nIf you are using knitr version 1.18 or higher, then the reticulate Python engine will be enabled by default whenever reticulate is installed and no further setup is required. If you are running an earlier version of knitr or want to disable the use of the reticulate engine see the Engine Setup section below."
  },
  {
    "objectID": "reticulate/doc/r_markdown.html#overview",
    "href": "reticulate/doc/r_markdown.html#overview",
    "title": "R Markdown Python Engine",
    "section": "",
    "text": "The reticulate package includes a Python engine for R Markdown that enables easy interoperability between Python and R chunks.\nPython chunks behave very similar to R chunks (including graphical output from matplotlib) and the two languages have full access each other’s objects. Built in conversion for many Python object types is provided, including NumPy arrays and Pandas data frames.\nIf you are using knitr version 1.18 or higher, then the reticulate Python engine will be enabled by default whenever reticulate is installed and no further setup is required. If you are running an earlier version of knitr or want to disable the use of the reticulate engine see the Engine Setup section below."
  },
  {
    "objectID": "reticulate/doc/r_markdown.html#python-version",
    "href": "reticulate/doc/r_markdown.html#python-version",
    "title": "R Markdown Python Engine",
    "section": "Python Version",
    "text": "Python Version\nBy default, reticulate uses the version of Python found on your PATH (i.e. Sys.which(\"python\")). If you want to use an alternate version you should add one of the use_python() family of functions to your R Markdown setup chunk, for example:\n\nSee the article on Python Version Configuration for additional details on configuring Python versions (including the use of conda or virtualenv environments)."
  },
  {
    "objectID": "reticulate/doc/r_markdown.html#python-chunks",
    "href": "reticulate/doc/r_markdown.html#python-chunks",
    "title": "R Markdown Python Engine",
    "section": "Python Chunks",
    "text": "Python Chunks\nPython code chunks work exactly like R code chunks: Python code is executed and any print or graphical (matplotlib) output is included within the document.\nPython chunks all execute within a single Python session so have access to all objects created in previous chunks. Chunk options like echo, include, etc. all work as expected.\nHere’s an R Markdown document that demonstrates this:\n\nRStudio v1.2 or greater for reticulate IDE support."
  },
  {
    "objectID": "reticulate/doc/r_markdown.html#calling-python-from-r",
    "href": "reticulate/doc/r_markdown.html#calling-python-from-r",
    "title": "R Markdown Python Engine",
    "section": "Calling Python from R",
    "text": "Calling Python from R\nAll objects created within Python chunks are available to R using the py object exported by the reticulate package. For example, the following code demonstrates reading and filtering a CSV file using Pandas then plotting the resulting data frame using ggplot2:\n\nSee the Calling Python from R article for additional details on how to interact with Python types from within R"
  },
  {
    "objectID": "reticulate/doc/r_markdown.html#calling-r-from-python",
    "href": "reticulate/doc/r_markdown.html#calling-r-from-python",
    "title": "R Markdown Python Engine",
    "section": "Calling R from Python",
    "text": "Calling R from Python\nYou can analogously access R objects within Python chunks via the r object. For example:"
  },
  {
    "objectID": "reticulate/doc/r_markdown.html#engine-setup",
    "href": "reticulate/doc/r_markdown.html#engine-setup",
    "title": "R Markdown Python Engine",
    "section": "Engine Setup",
    "text": "Engine Setup\nIf you are using a version of knitr prior to 1.18 then add this code to your setup chunk to enable the reticulate Python engine:\n\nIf you do not wish to use the reticulate Python engine then set the python.reticulate chunk option to FALSE:"
  },
  {
    "objectID": "reticulate/doc/python_packages.html",
    "href": "reticulate/doc/python_packages.html",
    "title": "Installing Python Packages",
    "section": "",
    "text": "Python packages are typically installed from one of two package repositories:\n\nPyPI; or\nConda\n\nAny Python package you install from PyPI or Conda can be used from R with reticulate.\nEach installation of Python on your system has its own set of packages. How reticulate selects a Python installation, and how you can configure the behavior, is described in the version vignette.\n\n\nWhen installing Python packages it’s best practice to isolate them within a Python environment (a named Python installation that exists for a specific project or purpose). This provides a measure of isolation, so that updating a Python package for one project doesn’t impact other projects. The risk for package incompatibilities is significantly higher with Python packages than it is with R packages, because unlike CRAN, PyPI does not enforce, or even check, if the current versions of packages currently available are compatible.\nThe reticulate package includes functions for creating Python environments (either virtualenvs or conda envs) and installing packages within them. Both virtual environments and conda environments are supported on all platforms (Linux, macOS, and Windows).\nNote that facilities to create and manage virtual environments (commonly refereed to as a “venv”) come with the Python standard library, and are the recommended way to create isolated python installations. Conda environments are supported as well, but be aware that there is the potential for binary incompatibilities between packages built by conda and packages built outside of conda (e.g., CRAN, or PPM)."
  },
  {
    "objectID": "reticulate/doc/python_packages.html#overview",
    "href": "reticulate/doc/python_packages.html#overview",
    "title": "Installing Python Packages",
    "section": "",
    "text": "Python packages are typically installed from one of two package repositories:\n\nPyPI; or\nConda\n\nAny Python package you install from PyPI or Conda can be used from R with reticulate.\nEach installation of Python on your system has its own set of packages. How reticulate selects a Python installation, and how you can configure the behavior, is described in the version vignette.\n\n\nWhen installing Python packages it’s best practice to isolate them within a Python environment (a named Python installation that exists for a specific project or purpose). This provides a measure of isolation, so that updating a Python package for one project doesn’t impact other projects. The risk for package incompatibilities is significantly higher with Python packages than it is with R packages, because unlike CRAN, PyPI does not enforce, or even check, if the current versions of packages currently available are compatible.\nThe reticulate package includes functions for creating Python environments (either virtualenvs or conda envs) and installing packages within them. Both virtual environments and conda environments are supported on all platforms (Linux, macOS, and Windows).\nNote that facilities to create and manage virtual environments (commonly refereed to as a “venv”) come with the Python standard library, and are the recommended way to create isolated python installations. Conda environments are supported as well, but be aware that there is the potential for binary incompatibilities between packages built by conda and packages built outside of conda (e.g., CRAN, or PPM)."
  },
  {
    "objectID": "reticulate/doc/python_packages.html#simple-installation",
    "href": "reticulate/doc/python_packages.html#simple-installation",
    "title": "Installing Python Packages",
    "section": "Simple Installation",
    "text": "Simple Installation\nThe reticulate package includes a py_install() function that can be used to install one or more Python packages. The packages will be by default be installed within a virtualenv or Conda environment named “r-reticulate”. For example:\nlibrary(reticulate)\npy_install(\"pandas\")\nThis provides a straightforward high-level interface to package installation and helps encourage the use of a common default environment (“r-reticulate”) across the installation of distinct Python packages.\nThere are also functions available for directly managing both Conda and virtualenvs for situations where you want more control over how packages are installed. These functions are covered in the sections below."
  },
  {
    "objectID": "reticulate/doc/python_packages.html#virtualenv-installation",
    "href": "reticulate/doc/python_packages.html#virtualenv-installation",
    "title": "Installing Python Packages",
    "section": "Virtualenv installation",
    "text": "Virtualenv installation\nThe following functions are available for managing Python virtualenvs:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nvirtualenv_list()\nList all available virtualenvs\n\n\nvirtualenv_create()\nCreate a new virtualenv\n\n\nvirtualenv_install()\nInstall a package within a virtualenv\n\n\nvirtualenv_remove()\nRemove individual packages or an entire virtualenv\n\n\n\nVirtual environments are by default located at ~/.virtualenvs. You can change this behavior by defining the WORKON_HOME environment variable.\nHere’s an example of using these functions to create an environment, install packages within it, then use the environment from R:\n\nlibrary(reticulate)\n\n# create a new environment \nvirtualenv_create(\"r-reticulate\")\n\n# install SciPy\nvirtualenv_install(\"r-reticulate\", \"scipy\")\n\n# import SciPy (it will be automatically discovered in \"r-reticulate\")\nscipy &lt;- import(\"scipy\")\n\nNote that you may have a given Python package installed in multiple environments, in that case you may want to call the use_virtualenv() function to ensure that a specific virtualenv is utilized by reticulate:\n\nlibrary(reticulate)\n\n# indicate that we want to use a specific virtualenv\nuse_virtualenv(\"r-reticulate\")\n\n# import SciPy (will use \"r-reticulate\" as per call to use_virtualenv)\nscipy &lt;- import(\"scipy\")\n\nVirtual environments are typically derived from (created using) a “starter” python installation. That is, there must be a python installation already installed on the system before you can create virtual environments. You can install a “venv starter” python in a variety of ways, however is most convenient:\n\nOn macOS and Windows, visit https://www.python.org/downloads/ and install a suitable version for your system.\nOn Linux, you can use prebuilt python binaries from https://github.com/rstudio/python-builds\nOn all platforms, you can use reticulate::install_python(). Note that on macOS and Linux, this will build Python from source on your system, which may take up to a few minutes.\n\nThere can be multiple versions of Python installed along-side each other on a system (for example, Python versions 3.9, 3.10, and 3.11). By default, reticulate will use the latest version installed on the system for creating the virtualenv. If you have specific version constraints on the version of Python required, you can supply those to the version argument–for example: virtualenv_create(version = \"&gt;=3.9\")\nAt anytime, you can see all the available virtualenv starters on your system by calling virtualenv_starter(all = TRUE). If you have Python venv starters installed in non-standard locations, you can inform reticulate where to look by setting the environment variable RETICULATE_VIRTUALENV_STARTER."
  },
  {
    "objectID": "reticulate/doc/python_packages.html#conda-installation",
    "href": "reticulate/doc/python_packages.html#conda-installation",
    "title": "Installing Python Packages",
    "section": "Conda installation",
    "text": "Conda installation\nThe following functions are available for managing Conda environments:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nconda_list()\nList all available conda environments\n\n\nconda_create()\nCreate a new conda environment\n\n\nconda_install()\nInstall a package within a conda environment\n\n\nconda_remove()\nRemove individual packages or an entire conda environment\n\n\n\nHere’s an example of using these functions to create an environment, install packages within it, then use the environment from R:\n\nlibrary(reticulate)\n\n# create a new environment \nconda_create(\"r-reticulate\")\n\n# install SciPy\nconda_install(\"r-reticulate\", \"scipy\")\n\n# import SciPy (it will be automatically discovered in \"r-reticulate\")\nscipy &lt;- import(\"scipy\")\n\nNote that you may have a given Python package installed in multiple Conda environments, in that case you may want to call the use_condaenv() function to ensure that a specific Conda environment is utilized by reticulate:\n\nlibrary(reticulate)\n\n# indicate that we want to use a specific condaenv\nuse_condaenv(\"r-reticulate\")\n\n# import SciPy (will use \"r-reticulate\" as per call to use_condaenv)\nscipy &lt;- import(\"scipy\")"
  },
  {
    "objectID": "reticulate/doc/python_packages.html#shell-installation",
    "href": "reticulate/doc/python_packages.html#shell-installation",
    "title": "Installing Python Packages",
    "section": "Shell installation",
    "text": "Shell installation\nYou can also use standard shell installation utilities (pip or conda) to install Python packages:\n# install into system level Python\n$ sudo pip install SciPy\n\n# install into active Conda environment\n$ conda install SciPy\nWhen doing this, be sure to make note of which version of Python your package has been installed within, and call use_python() functions as appropriate to ensure that this version is used by reticulate.\nAlternatively, within repl_python(), you can prefix ! to send a shell command, and the version of pip or conda used will already be configured for the Python installation reticulate is currently using.\n!pip install scipy"
  },
  {
    "objectID": "reticulate/doc/package.html",
    "href": "reticulate/doc/package.html",
    "title": "Using reticulate in an R Package",
    "section": "",
    "text": "If you write an R package that wraps one or more Python packages, it’s likely that you’ll be importing Python modules within the .onLoad method of your package so that you can have convenient access to them within the rest of the package source code.\nWhen you do this, you should use the delay_load flag to the import() function, for example:\n# global reference to scipy (will be initialized in .onLoad)\nscipy &lt;- NULL\n\n.onLoad &lt;- function(libname, pkgname) {\n  # use superassignment to update global reference to scipy\n  scipy &lt;&lt;- reticulate::import(\"scipy\", delay_load = TRUE)\n}\nUsing the delay_load flag has two important benefits:\n\nIt allows you to successfully load your package even when Python / Python packages are not installed on the target system (this is particularly important when testing on CRAN build machines).\nIt allows users to specify a desired location for Python before interacting with your package. For example:\nlibrary(mypackage)\nreticulate::use_virtualenv(\"~/pythonenvs/userenv\")\n# call functions from mypackage\n\nWithout the delay_load, Python would be loaded immediately and the user’s call to use_virtualenv would have no effect."
  },
  {
    "objectID": "reticulate/doc/package.html#delay-loading-python-modules",
    "href": "reticulate/doc/package.html#delay-loading-python-modules",
    "title": "Using reticulate in an R Package",
    "section": "",
    "text": "If you write an R package that wraps one or more Python packages, it’s likely that you’ll be importing Python modules within the .onLoad method of your package so that you can have convenient access to them within the rest of the package source code.\nWhen you do this, you should use the delay_load flag to the import() function, for example:\n# global reference to scipy (will be initialized in .onLoad)\nscipy &lt;- NULL\n\n.onLoad &lt;- function(libname, pkgname) {\n  # use superassignment to update global reference to scipy\n  scipy &lt;&lt;- reticulate::import(\"scipy\", delay_load = TRUE)\n}\nUsing the delay_load flag has two important benefits:\n\nIt allows you to successfully load your package even when Python / Python packages are not installed on the target system (this is particularly important when testing on CRAN build machines).\nIt allows users to specify a desired location for Python before interacting with your package. For example:\nlibrary(mypackage)\nreticulate::use_virtualenv(\"~/pythonenvs/userenv\")\n# call functions from mypackage\n\nWithout the delay_load, Python would be loaded immediately and the user’s call to use_virtualenv would have no effect."
  },
  {
    "objectID": "reticulate/doc/package.html#installing-python-dependencies",
    "href": "reticulate/doc/package.html#installing-python-dependencies",
    "title": "Using reticulate in an R Package",
    "section": "Installing Python Dependencies",
    "text": "Installing Python Dependencies\nYour R package likely depends on the installation of one or more Python packages. As a convenience to your users, you may want to provide a high-level R function to allow users to install these Python packages. By default, the Python packages should be installed in an isolated virtual environment, but it’s beneficial if users could easily configure multiple R packages to depend on a common Python environment (so that they can be easily used together).\nThe py_install() function provides a high-level interface for installing one or more Python packages. The packages will by default be installed within the currently active virtual environment or conda environment, (which is, by default, an environent named “r-reticulate”). For example:\nlibrary(reticulate)\npy_install(\"scipy\")\nYou can document the use of this function along with your package, or alternatively you can provide a wrapper function for py_install() that defaults to installing in a Python environment created specifically for your R package. For example:\n\ninstall_scipy &lt;- function(envname = \"r-scipy\", method = \"auto\", ...) {\n  reticulate::py_install(\"scipy\", envname = envname, \n                         method = method, ...)\n}\n\nFor a fuller discussion of how to use reticulate in an R package, include alternative approaches, and how to create a “pit of success” for R users with regards to managing Python installations, see the guide on Python Dependencies"
  },
  {
    "objectID": "reticulate/doc/package.html#checking-and-testing-on-cran",
    "href": "reticulate/doc/package.html#checking-and-testing-on-cran",
    "title": "Using reticulate in an R Package",
    "section": "Checking and Testing on CRAN",
    "text": "Checking and Testing on CRAN\nIf you use reticulate in another R package you need to account for the fact that when your package is submitted to CRAN, the CRAN test servers may not have Python, NumPy, or whatever other Python modules you are wrapping in your package. If you don’t do this then your package may fail to load and/or pass its tests when run on CRAN.\nThere are two things you should do to ensure your package is well behaved on CRAN:\n\nUse the delay_load option (as described above) to ensure that the module (and Python) is loaded only on its first use. For example:\n\n# python 'scipy' module I want to use in my package\nscipy &lt;- NULL\n\n.onLoad &lt;- function(libname, pkgname) {\n  # delay load foo module (will only be loaded when accessed via $)\n  scipy &lt;&lt;- import(\"scipy\", delay_load = TRUE)\n}\n\nWhen writing tests, check to see if your module is available and if it isn’t then skip the test. For example, if you are using the testthat package, you might do this:\n\n# helper function to skip tests if we don't have the 'foo' module\nskip_if_no_scipy &lt;- function() {\n  have_scipy &lt;- py_module_available(\"scipy\")\n  if (!have_scipy)\n    skip(\"scipy not available for testing\")\n}\n\n# then call this function from all of your tests\ntest_that(\"Things work as expected\", {\n  skip_if_no_scipy()\n  # test code here...\n})"
  },
  {
    "objectID": "reticulate/doc/package.html#implementing-s3-methods",
    "href": "reticulate/doc/package.html#implementing-s3-methods",
    "title": "Using reticulate in an R Package",
    "section": "Implementing S3 Methods",
    "text": "Implementing S3 Methods\nPython objects exposed by reticulate carry their Python classes into R, so it’s possible to write S3 methods to customize e.g. the str or print behavior for a given class (note that it’s not typically necessary that you do this since the default str and print methods call PyObject_Str, which typically provides an acceptable default behavior).\nIf you do decide to implement custom S3 methods for a Python class it’s important to keep in mind that when an R session ends the connection to Python objects is lost, so when the .RData saved from one R session is restored in a subsequent R session the Python objects are effectively lost (technically they become NULL R externalptr objects).\nBy default when you attempt to interact with a Python object from a previous session (a NULL R externalptr) an error is thrown. If you want to do something more customized in your S3 method you can use the py_is_null_xptr() function. For example:\n\nmethod.MyModule.MyPythonClass &lt;- function(x, y, ...) {\n  if (py_is_null_xptr(x))\n    # whatever is appropriate\n  else\n    # interact with the object\n}\n\nNote that this check isn’t required, as by default an R error will occur. If it’s desirable to avoid this error for any reason then you can use py_is_null_xptr() to do so.\nThe reticulate package exports a py_str generic method which is called from the str method only after doing appropriate validation (if the object is NULL then &lt;pointer: 0x0&gt; is returned). You can implement the py_str method as follows:\n\n#' @importFrom reticulate py_str\n#' @export\npy_str.MyModule.MyPythonClass &lt;- function(object, ...) {\n  # interact with the object to generate the string\n}\n\nThe print and summary methods for Python objects both call the str method by default, so if you implement py_str() you will automatically inherit implementations for those methods.\n\nConverting between R and Python\nreticulate provides the generics r_to_py() for converting R objects into Python objects, and py_to_r() for converting Python objects back into R objects. Package authors can provide methods for these generics to convert Python and R objects otherwise not handled by reticulate.\nreticulate provides conversion operators for some of the most commonly used Python objects, including:\n\nBuilt-in Python objects (lists, dictionaries, numbers, strings, tuples)\nNumPy arrays,\nPandas objects (Index, Series, DataFrame),\nPython datetime objects.\n\nIf you see that reticulate is missing support for conversion of one or more objects from these packages, please let us know and we’ll try to implement the missing converter. For Python packages not in this set, you can provide conversion operators in your own extension package.\n\n\nWriting your own r_to_py() methods\nr_to_py() accepts a convert argument, which controls how objects generated from the created Python object are converted. To illustrate, consider the difference between these two cases:\n\nlibrary(reticulate)\n\n# [convert = TRUE] =&gt; convert Python objects to R when appropriate\nsys &lt;- import(\"sys\", convert = TRUE)\nclass(sys$path)\n# [1] \"character\"\n\n# [convert = FALSE] =&gt; always return Python objects\nsys &lt;- import(\"sys\", convert = FALSE)\nclass(sys$path)\n# [1] \"python.builtin.list\" \"python.builtin.object\"\n\nThis is accomplished through the use of a convert flag, which is set on the Python object wrappers used by reticulate. Therefore, if you’re writing a method r_to_py.foo() for an object of class foo, you should take care to preserve the convert flag on the generated object. This is typically done by:\n\nPassing convert along to the appropriate lower-level r_to_py() method;\nExplicitly setting the convert attribute on the returned Python object.\n\nAs an example of the second:\n\n# suppose 'make_python_object()' creates a Python object\n# from R objects of class 'my_r_object'.\nr_to_py.my_r_object &lt;- function(x, convert) {\n  object &lt;- make_python_object(x)\n  assign(\"convert\", convert, envir = object)\n  object\n}"
  },
  {
    "objectID": "reticulate/doc/package.html#using-github-actions",
    "href": "reticulate/doc/package.html#using-github-actions",
    "title": "Using reticulate in an R Package",
    "section": "Using Github Actions",
    "text": "Using Github Actions\nGithub Actions are commonly used for continuous integration and testing of R packages. Making it work with reticulate is pretty simple - all you need to do is ensure that there is a valid Python installation on the runner, and that reticulate knows to use it. You can do this all with shell commands, or you can use functions in reticulate to do this. Here is an example sequence of steps demonstrating how you can do this with reticulate functions:\n\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          r-version: release\n\n      - uses: r-lib/actions/setup-r-dependencies@v2\n        with:\n          extra-packages: rcmdcheck reticulate\n\n      - uses: actions/setup-python@v4\n        with:\n          python-version: \"3.x\"\n\n      - name: setup r-reticulate venv\n        shell: Rscript {0}\n        run: |\n\n          path_to_python &lt;- reticulate::virtualenv_create(\n            envname = \"r-reticulate\",\n            python = Sys.which(\"python\"), # placed on PATH by the setup-python action\n            packages = c(\n              \"numpy\", \"any-other-python-packages-you-want-go-here\"\n            )\n          )\n\n          writeLines(sprintf(\"RETICULATE_PYTHON=%s\", path_to_python),\n                     Sys.getenv(\"GITHUB_ENV\"))\n\n      - uses: r-lib/actions/check-r-package@v2"
  },
  {
    "objectID": "reticulate/doc/arrays.html",
    "href": "reticulate/doc/arrays.html",
    "title": "Arrays in R and Python",
    "section": "",
    "text": "Dense data are stored contiguously in memory, addressed by a single index (the memory address). Array memory ordering schemes translate that single index into multiple indices corresponding to the array coordinates. For example, matrices have two indices: rows and columns. Three-d arrays have three, and so on."
  },
  {
    "objectID": "reticulate/doc/arrays.html#column-major-order",
    "href": "reticulate/doc/arrays.html#column-major-order",
    "title": "Arrays in R and Python",
    "section": "Column-major order",
    "text": "Column-major order\nColumn-major order is used by Fortran, Matlab, R, and most underlying core linear algebra libraries (BLAS). Sequential address locations are translated into array coordinates i, j, k, … so that the first array coordinates vary most rapidly with address, the next array coordinates less rapidly, and so on. For instance, four address locations 1, 2, 3, 4 are translated into a two by two matrix coordinate system (i, j) as:\naddress   i  j\n  1       1  1\n  2       2  1\n  3       1  2\n  4       2  2\nThe phrase column-major comes from the matrix example, where sequentially addressed data are laid out sequentially along columns of the matrix.\nThe concept of “row” and “column” don’t directly apply to n-d arrays, but the same idea holds. For instance the R language lays out sequential addresses from 1, 2, …, 8, into a 2x2x2 3-d array as:\naddress   i  j  k\n  1       1  1  1\n  2       2  1  1\n  3       1  2  1\n  4       2  2  1\n  5       1  1  2\n  6       2  1  2\n  7       1  2  2\n  8       2  2  2\nConsider the 3-d case shown above. Given array dimensions d1=2, d2=2, d3=2, a formula that takes 1-based coordinates i, j, k and returns address location a is  a = i + (j - 1) * d1 + (k - 1) * d2 * d1."
  },
  {
    "objectID": "reticulate/doc/arrays.html#row-major-order",
    "href": "reticulate/doc/arrays.html#row-major-order",
    "title": "Arrays in R and Python",
    "section": "Row-major order",
    "text": "Row-major order\nRow-major ordering is a different translation between sequential address indices and array coordinates, instead laying sequential data in memory across rows in matrices. Row-major ordering is sometimes called “C” style ordering and column-major ordering “Fortran” style. Python/NumPy refers to the orderings in array flags as C_CONTIGUOUS and F_CONTIGUOUS, respectively. For instance address locations 1, 2, 3, 4 are translated into a 2x2 matrix coordinate system (i, j) as:\naddress   i  j\n  1       1  1\n  2       1  2\n  3       2  1\n  4       2  2\nEfficient wrappers to BLAS routines exist for row-major ordered arrays. For completeness, here is a 2x2x2 3-d example layout:\naddress   i  j  k\n  1       1  1  1\n  2       1  1  2\n  3       1  2  1\n  4       1  2  2\n  5       2  1  1\n  6       2  1  2\n  7       2  2  1\n  8       2  2  2\nAnd similarly to above a formula for this example that converts these 1-based array coordinates to address indices is:  a = k + (j - 1) * d3 + (i - 1) * d3 * d2.\nSee the following notes for a general formula for row- and column-order coordinate to address mapping, but note the use of zero-based indexing.\n\nhttps://en.wikipedia.org/wiki/Row-_and_column-major_order#Address_calculation_in_general\nhttps://numpy.org/doc/stable/reference/arrays.ndarray.html"
  },
  {
    "objectID": "reticulate/doc/arrays.html#python",
    "href": "reticulate/doc/arrays.html#python",
    "title": "Arrays in R and Python",
    "section": "Python",
    "text": "Python\nThe Python NumPy library is very general. It can use either row-major or column-major ordered arrays, but it defaults to row-major ordering. NumPy also supports sophisticated views of data with custom strides across non-contiguous regions of memory."
  },
  {
    "objectID": "reticulate/doc/arrays.html#displaying-arrays",
    "href": "reticulate/doc/arrays.html#displaying-arrays",
    "title": "Arrays in R and Python",
    "section": "Displaying arrays",
    "text": "Displaying arrays\nR displays array data with unambiguously-labeled coordinate indices. Python doesn’t show this and displays n-d array data in different order than R (making matters somewhat confusing for R users). Consider the following example that creates and displays identical 4x3x2 arrays in R and Python:\narray(1:24, c(4,3,2))\n\n## , , 1\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\n## \n## , , 2\n##      [,1] [,2] [,3]\n## [1,]   13   17   21\n## [2,]   14   18   22\n## [3,]   15   19   23\n## [4,]   16   20   24\nimport numpy as np\nnp.reshape(np.arange(1,25), (4,3,2), \"F\")\n\n## array([[[ 1, 13],\n##         [ 5, 17],\n##         [ 9, 21]],\n##\n##        [[ 2, 14],\n##         [ 6, 18],\n##         [10, 22]],\n##\n##        [[ 3, 15],\n##         [ 7, 19],\n##         [11, 23]],\n##\n##        [[ 4, 16],\n##         [ 8, 20],\n##         [12, 24]]])\nIt’s easier to know which coordinates go where in R because they are labeled. Python, using column-major ordering, displays the same thing but in a different order where the first indices are grouped together in order. To see that these arrays are, in fact, the same, let’s pick out values along just the first “row”, that is values with a first index of 1 (R) or 0 (Python):\narray(1:24, c(4, 3, 2))[1,, ,drop=FALSE]\n\n## , , 1\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## \n## , , 2\n##      [,1] [,2] [,3]\n## [1,]   13   17   21\nnp.reshape(np.arange(1,25), (4,3,2), \"F\")[0]\n\n## array([[ 1, 13],\n##        [ 5, 17],\n##        [ 9, 21]])\nI specified R’s drop=FALSE argument to preserve array dimensionality above. If we use drop=TRUE (the default) then R returns a 3x2 array in column-major order–exactly the same result as Python above.\narray(1:24, c(4, 3, 2))[1,, ,drop=TRUE]\n\n##      [,1] [,2]\n## [1,]    1   13\n## [2,]    5   17\n## [3,]    9   21\nNote that the Python result is a special view of the original array data, not a copy. In this case it’s not stored in contiguous memory addresses and is neither really row- nor column-major. This is shown in the array flags:\nnp.reshape(np.arange(1,25), (4,3,2), \"F\")[0].flags\n\n##  C_CONTIGUOUS : False\n##  F_CONTIGUOUS : False\n##  OWNDATA : False\n##  WRITEABLE : True\n##  ALIGNED : True\n##  UPDATEIFCOPY : False"
  },
  {
    "objectID": "reticulate/doc/arrays.html#reticulate-with-care",
    "href": "reticulate/doc/arrays.html#reticulate-with-care",
    "title": "Arrays in R and Python",
    "section": "Reticulate with care",
    "text": "Reticulate with care\nThe reticulate package lets us easily mix R and Python code and data. Recall that R represents all dense arrays in column-major order but Python/NumPy can represent dense arrays much more generally. That difference warrants attention and can easily lead to confusion!\nRemember the following things when working with R and Python arrays, especially n-d arrays with n &gt; 2.\n\nDense R arrays are presented to Python/NumPy as column-major NumPy arrays.\nAll NumPy arrays (column-major, row-major, otherwise) are presented to R as column-major arrays, because that is the only kind of dense array that R understands.\nR and Python print arrays differently.\n\nAlso worth knowing:\n\nPython array indices are zero-based, R indices are 1-based.\nR arrays are only copied to Python when they need to be, otherwise data are shared.\nPython arrays are always copied when moved into R arrays. This can sometimes lead to three copies of any one array in memory at any one time (at the moment this was written). Future versions will reduce that copy overhead to two.\n\nPoint number 3. introduces the most potential confusion. Let’s look at some examples to explore these points.\nThe following example creates a 2x2x2 array in Python using native NumPy row-major ordering and imports it into R. Despite the fact that they print out differently, they are in fact the same.\nlibrary(reticulate)\nnp &lt;- import(\"numpy\", convert=FALSE)\n(x &lt;- np$arange(1, 9)$reshape(2L, 2L, 2L))\n\n## [[[ 1.  2.]\n##   [ 3.  4.]]\n## \n##  [[ 5.  6.]\n##   [ 7.  8.]]]\n\n(y &lt;- py_to_r(x))\n\n## , , 1\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    5    7\n## \n## , , 2\n##      [,1] [,2]\n## [1,]    2    4\n## [2,]    6    8\nWait a minute! They look different! But remember Python’s print order is different. The first “rows” (first index values) are grouped together. Let’s pull out elements with first index of 1 in the R result, with and without dropping the unused dimension to show precisely what we’re indexing here:\ny[1,,, drop=FALSE]\n\n## , , 1\n##      [,1] [,2]\n## [1,]    1    3\n## \n## , , 2\n##      [,1] [,2]\n## [1,]    2    4\n\ny[1,,, drop=TRUE]\n\n##      [,1] [,2]\n## [1,]    1    2\n## [2,]    3    4\nNote that this is the same as the first block printed in the Python output above! These arrays really are the same in Python and R, respectively. Their apparent differences are merely a result of printing.\n\nAnother example\nLet’s look at this again with another example, this time with an array with different lengths along each dimension to make things even more clear (hopefully). Consider the following 4x3x2 array constructed in Python in row-major order:\nnp &lt;- import(\"numpy\", convert=FALSE)\n(x &lt;- np$reshape(np$arange(1, 25), c(4L, 3L, 2L)))\n\n## [[[  1.   2.]\n##   [  3.   4.]\n##   [  5.   6.]]\n## \n##  [[  7.   8.]\n##   [  9.  10.]\n##   [ 11.  12.]]\n## \n##  [[ 13.  14.]\n##   [ 15.  16.]\n##   [ 17.  18.]]\n## \n##  [[ 19.  20.]\n##   [ 21.  22.]\n##   [ 23.  24.]]]\n\n(y &lt;- py_to_r(x))\n\n## , , 1\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    7    9   11\n## [3,]   13   15   17\n## [4,]   19   21   23\n## \n## , , 2\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    8   10   12\n## [3,]   14   16   18\n## [4,]   20   22   24\nAgain, they look quite different but the R and Python arrays are really the same. Let’s pick out the sub-array with third index = 0 (Python), equivalently the third index = 1 in R.\nnp$take(x, 0L, 2L)\n\n## [[  1.   3.   5.]\n##  [  7.   9.  11.]\n##  [ 13.  15.  17.]\n##  [ 19.  21.  23.]]\n\ny[, , 1]\n\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    7    9   11\n## [3,]   13   15   17\n## [4,]   19   21   23\nThe NumPy take() function is equivalent in this example to the Python notation x[:, :, 0]; that is, entries with third dimension index = 0. See https://numpy.org/doc/stable/reference/generated/numpy.take.html for more information.\nThe corresponding R notation, y[, , 1], returns the same thing in this example: a 4x3 matrix.\nDespite different internal memory ordering, and particularly despite awkward differences in printing arrays, the arrays are the same and are indexed the same way in each language respectively."
  },
  {
    "objectID": "reticulate/doc/arrays.html#what-about-going-from-r-column-major-arrays-to-python",
    "href": "reticulate/doc/arrays.html#what-about-going-from-r-column-major-arrays-to-python",
    "title": "Arrays in R and Python",
    "section": "What about going from R column-major arrays to Python?",
    "text": "What about going from R column-major arrays to Python?\nThe previous examples focused on row-major arrays natively constructed in Python. Let’s see what happens when we start with column-major arrays from R and work with them in Python.\n(y &lt;- array(1:24, c(4, 3, 2)))  # In R\n\n## , , 1\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\n## \n## , , 2\n##      [,1] [,2] [,3]\n## [1,]   13   17   21\n## [2,]   14   18   22\n## [3,]   15   19   23\n## [4,]   16   20   24\n\n(x &lt;- np$array(y))              # and now in Python\n\n## [[[ 1 13]\n##   [ 5 17]\n##   [ 9 21]]\n## \n##  [[ 2 14]\n##   [ 6 18]\n##   [10 22]]\n## \n##  [[ 3 15]\n##   [ 7 19]\n##   [11 23]]\n## \n##  [[ 4 16]\n##   [ 8 20]\n##   [12 24]]]\nNote that the Python version takes advantage of NumPy’s extraordinary flexibility and preserves R’s column-major ordering:\nx$flags\n\n##   C_CONTIGUOUS : False\n##   F_CONTIGUOUS : True\n##   OWNDATA : True\n##   WRITEABLE : True\n##   ALIGNED : True\n##   UPDATEIFCOPY : False\nYou can probably tell already from the previous sections that these arrays are the same, and obey the same indexing conventions. The next example selects a subarray such that the third index of each array is 0 (Python) or 1 (R):\ny[, , 1]\n\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\n\nnp$take(x, 0L, 2L)\n\n## [[ 1  5  9]\n##  [ 2  6 10]\n##  [ 3  7 11]\n##  [ 4  8 12]]\nIt’s important to remember that the order is preserved from Python when copying an array result back into R:\npy_to_r(np$take(x, 0L, 2L))\n\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\nThe upshot is that arrays created by either R or Python are indexed exactly the same in either language.\n\nBut the array I created in R ends up transposed compared to ones I create in Python?\nRight. That’s just a simple consequence of the default column-major and row-major formats used in R and NumPy respectively. You are always free to use R’s column-major format directly in Python, for example using the “F” flag below (for Fortran):\nnp$reshape(np$arange(1, 25), c(4L, 3L, 2L), \"F\")\n\n## [[[  1.  13.]\n##   [  5.  17.]\n##   [  9.  21.]]\n## \n##  [[  2.  14.]\n##   [  6.  18.]\n##   [ 10.  22.]]\n## \n##  [[  3.  15.]\n##   [  7.  19.]\n##   [ 11.  23.]]\n## \n##  [[  4.  16.]\n##   [  8.  20.]\n##   [ 12.  24.]]]\nNote that the result is just like the one we got starting from R above.\nRe-arranging R arrays into row-major order requires more work. R is less flexible than Python and we can’t explicitly change R’s memory order representation. When the array is a matrix when we can simply use byrow=TRUE. In the n-d array case, a portion of the problem can be reduced to using byrow=TRUE followed by judicious index permutation with aperm(). Here is one somewhat inefficient example:\ny &lt;- aperm(array(matrix(1:24, c(3 * 4, 2), byrow=TRUE),\n           c(3, 4, 2)), c(2, 1, 3))\nSee the last section below for a different example.\nWe can verify that the above ugly expression exactly reproduces a NumPy row-major array by subtracting our R array from a native Python one:\nnp &lt;- import(\"numpy\", convert=FALSE)\no  &lt;- import(\"operator\", convert=FALSE)\n\no$sub(np$arange(1, 25)$reshape(4L, 3L, 2L), np$array(y))\n\n## [[[ 0.  0.]\n##   [ 0.  0.]\n##   [ 0.  0.]]\n## \n##  [[ 0.  0.]\n##   [ 0.  0.]\n##   [ 0.  0.]]\n## \n##  [[ 0.  0.]\n##   [ 0.  0.]\n##   [ 0.  0.]]\n## \n##  [[ 0.  0.]\n##   [ 0.  0.]\n##   [ 0.  0.]]]\nThe above NumPy arrays are the same, their element-wise difference is zero.\n\n\nReshaping arrays\nIn R you would typically reshape an array using the dim&lt;-() function. For example:\ndim(x) &lt;- c(1000, 28, 28)\nIn R, this operation simply changes the “dim” attribute of the array, effectively re-interpreting the array indices as specified using column-major semantics.\nHowever, the NumPy reshape method uses row-major semantics by default, so if you are mixing R and Python code that reshapes arrays you will find that the reshaping will be inconsistent if you use the R dim&lt;-() function.\nTo overcome this inconsistency, there is an array_reshape() function which will reshape an R array using row-major semantics (i.e. will fill the new dimensions in row-major rather than col-major order). The example above would be re-written as:\nx &lt;- array_reshape(x, c(1000, 28, 28))\nHere’s a further example to illustrate the difference:\n# let's construct a 2x2 array from a vector of 4 elements\nx &lt;- 1:4\n\n# rearrange will fill the array row-wise\narray_reshape(x, c(2, 2))\n#      [,1] [,2]\n# [1,]    1    2\n# [2,]    3    4\n\n# setting the dimensions 'fills' the array col-wise\ndim(x) &lt;- c(2, 2)\nx\n#      [,1] [,2]\n# [1,]    1    3\n# [2,]    2    4"
  },
  {
    "objectID": "reticulate/doc/arrays.html#other-differences-warranting-caution",
    "href": "reticulate/doc/arrays.html#other-differences-warranting-caution",
    "title": "Arrays in R and Python",
    "section": "Other differences warranting caution",
    "text": "Other differences warranting caution\nIt’s worth noting that analogs of R’s apply() function in Python behave differently. The following excellent Mathesaurus reference https://mathesaurus.sourceforge.net/r-numpy.html applies well to matrices and vectors, but is misleading for n-d arrays with n &gt; 2.\nIn particular, Mathesaurus says that if a is a matrix, then the sum of each column in Python may be computed by a.sum(0), and in R (among other possible ways) by apply(a, 2, sum). Although correct for matrices, this is in general not quite right. A more precise R analog of NumPy’s a.sum(0) is apply(a, seq_along(dim(a))[-1], sum). In other words, a.sum(0) means sum over the first dimension, returning an array of the same dimensions as a but with the first dimension removed.\nIt’s easy to be confused by this, so let’s see an example using a 4x3x2 array, first in Python:\nlibrary(reticulate)\nnp &lt;- import(\"numpy\", convert=FALSE)\nx  &lt;- np$arange(1, 25)$reshape(c(4L, 3L, 2L))\nx$sum(0)   # N. B. a 3x2 matrix!\n\n## [[ 40.  44.]\n##  [ 48.  52.]\n##  [ 56.  60.]]\n\n# N. B. A tuple() object is required here (NumPy vectors won't work)\nx$sum(tuple(1L, 2L))\n\n## [  21.   57.   93.  129.]\nAnd now the corresponding sums in R:\ny &lt;- py_to_r(x)\napply(y, dim(y)[-1], sum)\n\n##      [,1] [,2] [,3]\n## [1,]   40   48   56\n## [2,]   44   52   60\n\napply(y, 1, sum)\n\n## [1]  21  57  93 129"
  },
  {
    "objectID": "model.html",
    "href": "model.html",
    "title": "Model",
    "section": "",
    "text": "Code\ninstall.packages(\"reticulate\")\n\n\nThe following package(s) will be installed:\n- reticulate [1.36.1]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing reticulate ...                     OK [linked from cache]\nSuccessfully installed 1 package in 20 milliseconds.\n\n\nCode\nrenv::snapshot()\n\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n- The lockfile is already up to date.\nCode\nlibrary(reticulate)\nuse_virtualenv(\"C:/Users/C25Swayam.Singh/Documents/.virtualenvs/myenv\", required = TRUE)\npy_config()\n\n\npython:         C:/Users/C25Swayam.Singh/Documents/.virtualenvs/myenv/Scripts/python.exe\nlibpython:      C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312/python312.dll\npythonhome:     C:/Users/C25Swayam.Singh/Documents/.virtualenvs/myenv\nversion:        3.12.3 (tags/v3.12.3:f6650f9, Apr  9 2024, 14:05:25) [MSC v.1938 64 bit (AMD64)]\nArchitecture:   64bit\nnumpy:          C:/Users/C25Swayam.Singh/Documents/.virtualenvs/myenv/Lib/site-packages/numpy\nnumpy_version:  1.26.4\n\nNOTE: Python version was forced by use_python() function\n\n\nCode\npy_run_string(\"import sklearn\")\ninstall.packages(\"palmerpenguins\")\n\n\nThe following package(s) will be installed:\n- palmerpenguins [0.1.1]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing palmerpenguins ...                 OK [linked from cache]\nSuccessfully installed 1 package in 17 milliseconds.\n\n\nCode\nimport(\"numpy\")\n\n\nModule(numpy)\n\n\nCode\nimport(\"sklearn.linear_model\")\n\n\nModule(sklearn.linear_model)\n\n\nCode\nimport(\"sklearn\")\n\n\nModule(sklearn)\n\n\nCode\nlibrary(palmerpenguins)\nCode\nrenv::status()\n\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\nNo issues found -- the project is in a consistent state.\n\n\nCode\nrenv::snapshot()\n\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n- The lockfile is already up to date.\nCode\nfrom palmerpenguins import penguins\nfrom pandas import get_dummies\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn import preprocessing\nCode\ndf = penguins.load_penguins().dropna()\n\ndf.head(3)\n\n\n  species     island  bill_length_mm  ...  body_mass_g     sex  year\n0  Adelie  Torgersen            39.1  ...       3750.0    male  2007\n1  Adelie  Torgersen            39.5  ...       3800.0  female  2007\n2  Adelie  Torgersen            40.3  ...       3250.0  female  2007\n\n[3 rows x 8 columns]"
  },
  {
    "objectID": "model.html#define-model-and-fit",
    "href": "model.html#define-model-and-fit",
    "title": "Model",
    "section": "Define Model and Fit",
    "text": "Define Model and Fit\n\n\nCode\nX = get_dummies(df[['bill_length_mm', 'species', 'sex']], drop_first = True)\ny = df['body_mass_g']\n\nmodel = LinearRegression().fit(X, y)\n\n\n\n\nCode\n# Import necessary libraries\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestRegressor\nfrom vetiver import vetiver_model, vetiver_pin_write\nfrom pins import board_folder"
  },
  {
    "objectID": "model.html#get-data",
    "href": "model.html#get-data",
    "title": "Model",
    "section": "Get Data",
    "text": "Get Data\n\n\nCode\nfrom palmerpenguins import load_penguins\nimport duckdb\n\ndf_penguins = load_penguins()\n\ncon = duckdb.connect(database=':memory:')  \n\ncon.register('penguins', df_penguins)\n\n\n&lt;duckdb.duckdb.DuckDBPyConnection object at 0x0000025100841C30&gt;\n\n\nCode\ndf_result = con.execute(\"SELECT * FROM penguins\").fetchdf()\n\ncon.close()\n\nprint(df_result.head(3))\n\n\n  species     island  bill_length_mm  ...  body_mass_g     sex  year\n0  Adelie  Torgersen            39.1  ...       3750.0    male  2007\n1  Adelie  Torgersen            39.5  ...       3800.0  female  2007\n2  Adelie  Torgersen            40.3  ...       3250.0  female  2007\n\n[3 rows x 8 columns]"
  },
  {
    "objectID": "model.html#define-model-and-fit-1",
    "href": "model.html#define-model-and-fit-1",
    "title": "Model",
    "section": "Define Model and Fit",
    "text": "Define Model and Fit\n\n\nCode\nX = get_dummies(df[['bill_length_mm', 'species', 'sex']], drop_first = True)\ny = df['body_mass_g']\n\nmodel = LinearRegression().fit(X, y)"
  },
  {
    "objectID": "model.html#get-some-information",
    "href": "model.html#get-some-information",
    "title": "Model",
    "section": "Get some information",
    "text": "Get some information\n\n\nCode\nprint(f\"R^2 {model.score(X,y)}\")\n\n\nR^2 0.8555368759537614\n\n\nCode\nprint(f\"Intercept {model.intercept_}\")\n\n\nIntercept 2169.269720939398\n\n\nCode\nprint(f\"Columns {X.columns}\")\n\n\nColumns Index(['bill_length_mm', 'species_Chinstrap', 'species_Gentoo', 'sex_male'], dtype='object')\n\n\nCode\nprint(f\"Coefficients {model.coef_}\")\n\n\nCoefficients [  32.53688677 -298.76553447 1094.86739145  547.36692408]"
  },
  {
    "objectID": "model.html#turn-into-vetiver-model",
    "href": "model.html#turn-into-vetiver-model",
    "title": "Model",
    "section": "Turn into Vetiver Model",
    "text": "Turn into Vetiver Model\n\n\nCode\nfrom vetiver import VetiverModel\nv = VetiverModel(model, model_name='penguin_model', prototype_data=X)"
  },
  {
    "objectID": "model.html#save-to-board",
    "href": "model.html#save-to-board",
    "title": "Model",
    "section": "Save to Board",
    "text": "Save to Board\n\n\nCode\nfrom vetiver import vetiver_pin_write\nfrom pins import board_folder\n\nv = VetiverModel(model, model_name='penguin_model', prototype_data=X)\nmodel_board = board_folder(\"/data/model\", allow_pickle_read=True)\nvetiver_pin_write(model_board, v)\n\n\nModel Cards provide a framework for transparent, responsible reporting. \n Use the vetiver `.qmd` Quarto template as a place to start, \n with vetiver.model_card()\nWriting pin:\nName: 'penguin_model'\nVersion: 20240425T152217Z-cf3d4\n\n\n\n\nCode\nlibrary(reticulate)\nuse_virtualenv(\"C:/Users/C25Swayam.Singh/Documents/.virtualenvs/myenv\", required = TRUE)\npy_config()\n\n\npython:         C:/Users/C25Swayam.Singh/Documents/.virtualenvs/myenv/Scripts/python.exe\nlibpython:      C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312/python312.dll\npythonhome:     C:/Users/C25Swayam.Singh/Documents/.virtualenvs/myenv\nversion:        3.12.3 (tags/v3.12.3:f6650f9, Apr  9 2024, 14:05:25) [MSC v.1938 64 bit (AMD64)]\nArchitecture:   64bit\nnumpy:          C:/Users/C25Swayam.Singh/Documents/.virtualenvs/myenv/Lib/site-packages/numpy\nnumpy_version:  1.26.4\n\nNOTE: Python version was forced by use_python() function\n\n\nCode\n#from vetiver import vetiver_model_card\n\n# Assuming 'v' is your VetiverModel object\n#vetiver_model_card(v, output_file=\"penguin_model_card.qmd\")\n\n\n\n\nCode\npy_run_string(\"import fastapi\")\n\n\n\n\nCode\npy_run_string(\"from vetiver import VetiverAPI\")\npy_run_string(\"app = VetiverAPI(v, check_prototype = True)\")"
  },
  {
    "objectID": "eda.html",
    "href": "eda.html",
    "title": "Penguins EDA",
    "section": "",
    "text": "Code\nrenv::init()\n\n\nA large number of files (1407 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\nCode\ninstall.packages(\"dplyr\")\n\n\nThe following package(s) will be installed:\n- dplyr [1.1.4]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing dplyr ...                          OK [linked from cache]\nSuccessfully installed 1 package in 31 milliseconds.\n\n\nCode\nlibrary(dplyr)\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\nCode\nrenv::snapshot()\n\n\nA large number of files (1407 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n- The lockfile is already up to date.\nCode\ninstall.packages(\"palmerpenguins\")\n\n\nThe following package(s) will be installed:\n- palmerpenguins [0.1.1]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing palmerpenguins ...                 OK [linked from cache]\nSuccessfully installed 1 package in 32 milliseconds.\n\n\nCode\nlibrary(palmerpenguins)\nCode\nrenv::snapshot()\n\n\nA large number of files (1407 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n- The lockfile is already up to date.\nCode\nlibrary(palmerpenguins)\nlibrary(dplyr)\nlibrary(ggplot2)\n\ndf &lt;- palmerpenguins::penguins\nCode\ndf %&gt;%\n  group_by(species, sex) %&gt;%\n  summarise(\n    across(\n      where(is.numeric), \n      \\(x) mean(x, na.rm = TRUE)\n      )\n    ) %&gt;%\n  knitr::kable()\n\n\n`summarise()` has grouped output by 'species'. You can override using the\n`.groups` argument.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nsex\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nyear\n\n\n\n\nAdelie\nfemale\n37.25753\n17.62192\n187.7945\n3368.836\n2008.055\n\n\nAdelie\nmale\n40.39041\n19.07260\n192.4110\n4043.493\n2008.055\n\n\nAdelie\nNA\n37.84000\n18.32000\n185.6000\n3540.000\n2007.000\n\n\nChinstrap\nfemale\n46.57353\n17.58824\n191.7353\n3527.206\n2007.971\n\n\nChinstrap\nmale\n51.09412\n19.25294\n199.9118\n3938.971\n2007.971\n\n\nGentoo\nfemale\n45.56379\n14.23793\n212.7069\n4679.741\n2008.069\n\n\nGentoo\nmale\n49.47377\n15.71803\n221.5410\n5484.836\n2008.066\n\n\nGentoo\nNA\n45.62500\n14.55000\n215.7500\n4587.500\n2008.400"
  },
  {
    "objectID": "eda.html#penguin-size-vs-mass-by-species",
    "href": "eda.html#penguin-size-vs-mass-by-species",
    "title": "Penguins EDA",
    "section": "Penguin Size vs Mass by Species",
    "text": "Penguin Size vs Mass by Species\n\n\nCode\ndf %&gt;%\n  ggplot(aes(x = bill_length_mm, y = body_mass_g, color = species)) +\n  geom_point() + \n  geom_smooth(method = \"lm\")\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\nCode\ndf %&gt;%\n  ggplot(aes(x = body_mass_g, fill = species)) +\n  geom_histogram(bins = 30, alpha = 0.6, position = \"identity\") +\n  labs(title = \"Histogram of Penguin Body Mass by Species\")\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`)."
  },
  {
    "objectID": "eda.html#classification-with-a-random-forest-model",
    "href": "eda.html#classification-with-a-random-forest-model",
    "title": "Penguins EDA",
    "section": "Classification With a Random Forest Model",
    "text": "Classification With a Random Forest Model\nThe code trains a decision tree model to classify penguin sex, visualizes the tree, assesses its predictive accuracy, and creates a confusion matrix for the predictions.\n\n\nCode\n# Load necessary libraries\nlibrary(palmerpenguins)\nlibrary(dplyr)\nlibrary(ggplot2)\ninstall.packages(\"randomForest\")\n\n\nThe following package(s) will be installed:\n- randomForest [4.7-1.1]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing randomForest ...                   OK [linked from cache]\nSuccessfully installed 1 package in 24 milliseconds.\n\n\nCode\nlibrary(randomForest)\n\n\nrandomForest 4.7-1.1\n\n\nType rfNews() to see new features/changes/bug fixes.\n\n\n\nAttaching package: 'randomForest'\n\n\nThe following object is masked from 'package:ggplot2':\n\n    margin\n\n\nThe following object is masked from 'package:dplyr':\n\n    combine\n\n\nCode\ninstall.packages(\"broom\")\n\n\nThe following package(s) will be installed:\n- broom [1.0.5]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing broom ...                          OK [linked from cache]\nSuccessfully installed 1 package in 27 milliseconds.\n\n\nCode\nlibrary(broom) # For tidy augmentation of model predictions\n\n# Prepare the data, removing rows with missing values\npenguins_clean &lt;- na.omit(penguins)\n\n# Random Forest model specification\nrf_spec &lt;- randomForest(sex ~ ., data = penguins_clean, importance = TRUE, ntree = 500)\n\n# Fit the Random Forest model\nrf_fit &lt;- randomForest(sex ~ ., data = penguins_clean, importance = TRUE, ntree = 500)\n\n# View the importance of variables\nimportance(rf_fit)\n\n\n                     female      male MeanDecreaseAccuracy MeanDecreaseGini\nspecies           13.791440 18.119864            22.139508         7.858615\nisland             8.210468  5.971069            10.950605         3.910339\nbill_length_mm    26.039126 20.599254            30.629328        32.326740\nbill_depth_mm     33.415734 36.114854            45.354716        45.511408\nflipper_length_mm 11.811815 14.137165            19.061516        20.684744\nbody_mass_g       41.551814 34.804987            51.091079        48.686695\nyear               3.198159  4.433604             5.177902         3.359945\n\n\nCode\n# Predict on the same dataset to get the accuracy (confusion matrix)\npred &lt;- predict(rf_fit, penguins_clean)\nconf_mat &lt;- table(penguins_clean$sex, pred)\n\n# Calculate accuracy\naccuracy &lt;- sum(diag(conf_mat)) / sum(conf_mat)\n\n# Print out the accuracy\nprint(accuracy)\n\n\n[1] 1\n\n\nCode\n# Plotting variable importance\nvarImpPlot(rf_fit)\n\n\n\n\n\n\n\n\n\nCode\n# Output the confusion matrix\nprint(conf_mat)\n\n\n        pred\n         female male\n  female    165    0\n  male        0  168"
  },
  {
    "objectID": "Final Project.html",
    "href": "Final Project.html",
    "title": "Final Project",
    "section": "",
    "text": "install.packages(\"Matrix\")\n\nThe following package(s) will be installed:\n- Matrix [1.6-5]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing Matrix ...                         OK [linked from cache]\nSuccessfully installed 1 package in 37 milliseconds.\n\n\n\ninstall.packages(\"lattice\")\n\nThe following package(s) will be installed:\n- lattice [0.22-6]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing lattice ...                        OK [linked from cache]\nSuccessfully installed 1 package in 23 milliseconds.\n\n\n\nrenv::init()\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n\n\nrenv::snapshot()\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n- The lockfile is already up to date.\n\n\n\ngetwd()\n\n[1] \"C:/Users/C25Swayam.Singh/Desktop/Final Project\"\n\n\n\nrenv::status()\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\nNo issues found -- the project is in a consistent state.\n\n\n\n.libPaths()\n\n[1] \"C:/Users/C25Swayam.Singh/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\"\n[2] \"C:/Users/C25Swayam.Singh/AppData/Local/R/cache/R/renv/sandbox/R-4.3/x86_64-w64-mingw32/bab7db7c\"              \n\n\n\ninstall.packages(\"renv\")\n\nThe following package(s) will be installed:\n- renv [1.0.7]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing renv ...                           OK [linked from cache]\nSuccessfully installed 1 package in 17 milliseconds.\n\n\n\nrenv::snapshot()\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n- The lockfile is already up to date.\n\n\n\ninstall.packages(\"reticulate\")\n\nThe following package(s) will be installed:\n- reticulate [1.36.1]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing reticulate ...                     OK [linked from cache]\nSuccessfully installed 1 package in 17 milliseconds.\n\nrenv::snapshot()\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n- The lockfile is already up to date.\n\n\n\nlibrary(reticulate)\nuse_python(\"C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312/python.exe\", required = TRUE)\npy_config()\n\npython:         C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312/python.exe\nlibpython:      C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312/python312.dll\npythonhome:     C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312\nversion:        3.12.3 (tags/v3.12.3:f6650f9, Apr  9 2024, 14:05:25) [MSC v.1938 64 bit (AMD64)]\nArchitecture:   64bit\nnumpy:          C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312/Lib/site-packages/numpy\nnumpy_version:  1.26.4\n\nNOTE: Python version was forced by use_python() function"
  },
  {
    "objectID": "Final Project.html#quarto",
    "href": "Final Project.html#quarto",
    "title": "Final Project",
    "section": "",
    "text": "install.packages(\"Matrix\")\n\nThe following package(s) will be installed:\n- Matrix [1.6-5]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing Matrix ...                         OK [linked from cache]\nSuccessfully installed 1 package in 37 milliseconds.\n\n\n\ninstall.packages(\"lattice\")\n\nThe following package(s) will be installed:\n- lattice [0.22-6]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing lattice ...                        OK [linked from cache]\nSuccessfully installed 1 package in 23 milliseconds.\n\n\n\nrenv::init()\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n\n\nrenv::snapshot()\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n- The lockfile is already up to date.\n\n\n\ngetwd()\n\n[1] \"C:/Users/C25Swayam.Singh/Desktop/Final Project\"\n\n\n\nrenv::status()\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\nNo issues found -- the project is in a consistent state.\n\n\n\n.libPaths()\n\n[1] \"C:/Users/C25Swayam.Singh/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\"\n[2] \"C:/Users/C25Swayam.Singh/AppData/Local/R/cache/R/renv/sandbox/R-4.3/x86_64-w64-mingw32/bab7db7c\"              \n\n\n\ninstall.packages(\"renv\")\n\nThe following package(s) will be installed:\n- renv [1.0.7]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing renv ...                           OK [linked from cache]\nSuccessfully installed 1 package in 17 milliseconds.\n\n\n\nrenv::snapshot()\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n- The lockfile is already up to date.\n\n\n\ninstall.packages(\"reticulate\")\n\nThe following package(s) will be installed:\n- reticulate [1.36.1]\nThese packages will be installed into \"~/AppData/Local/R/cache/R/renv/library/Final Project-bc0da2df/R-4.3/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing reticulate ...                     OK [linked from cache]\nSuccessfully installed 1 package in 17 milliseconds.\n\nrenv::snapshot()\n\nA large number of files (1429 in total) have been discovered.\nIt may take renv a long time to crawl these files for dependencies.\nConsider using .renvignore to ignore irrelevant files.\nSee `?renv::dependencies` for more information.\nSet `options(renv.config.dependencies.limit = Inf)` to disable this warning.\n\n- The lockfile is already up to date.\n\n\n\nlibrary(reticulate)\nuse_python(\"C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312/python.exe\", required = TRUE)\npy_config()\n\npython:         C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312/python.exe\nlibpython:      C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312/python312.dll\npythonhome:     C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312\nversion:        3.12.3 (tags/v3.12.3:f6650f9, Apr  9 2024, 14:05:25) [MSC v.1938 64 bit (AMD64)]\nArchitecture:   64bit\nnumpy:          C:/Users/C25Swayam.Singh/AppData/Local/Programs/Python/Python312/Lib/site-packages/numpy\nnumpy_version:  1.26.4\n\nNOTE: Python version was forced by use_python() function"
  },
  {
    "objectID": "numpy/random/LICENSE.html",
    "href": "numpy/random/LICENSE.html",
    "title": "NCSA Open Source License",
    "section": "",
    "text": "This software is dual-licensed under the The University of Illinois/NCSA Open Source License (NCSA) and The 3-Clause BSD License\n\nNCSA Open Source License\nCopyright (c) 2019 Kevin Sheppard. All rights reserved.\nDeveloped by: Kevin Sheppard (kevin.sheppard@economics.ox.ac.uk, kevin.k.sheppard@gmail.com) http://www.kevinsheppard.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimers in the documentation and/or other materials provided with the distribution.\nNeither the names of Kevin Sheppard, nor the names of any contributors may be used to endorse or promote products derived from this Software without specific prior written permission.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.\n\n\n3-Clause BSD License\nCopyright (c) 2019 Kevin Sheppard. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nComponents\nMany parts of this module have been derived from original sources, often the algorithm’s designer. Component licenses are located with the component code."
  },
  {
    "objectID": "reticulate/doc/calling_python.html",
    "href": "reticulate/doc/calling_python.html",
    "title": "Calling Python from R",
    "section": "",
    "text": "The reticulate package provides an R interface to Python modules, classes, and functions. For example, this code imports the Python os module and calls some functions within it:\n\nlibrary(reticulate)\nos &lt;- import(\"os\")\nos$listdir(\".\")\n\n [1] \".git\"             \".gitignore\"       \".Rbuildignore\"    \".RData\"          \n [5] \".Rhistory\"        \".Rproj.user\"      \".travis.yml\"      \"appveyor.yml\"    \n [9] \"DESCRIPTION\"      \"docs\"             \"external\"         \"index.html\"      \n[13] \"index.Rmd\"        \"inst\"             \"issues\"           \"LICENSE\"         \n[17] \"man\"              \"NAMESPACE\"        \"NEWS.md\"          \"pkgdown\"         \n[21] \"R\"                \"README.md\"        \"reticulate.Rproj\" \"src\"             \n[25] \"tests\"            \"vignettes\"      \nFunctions and other data within Python modules and classes can be accessed via the $ operator (analogous to the way you would interact with an R list, environment, or reference class).\nThe reticulate package is compatible with all versions of Python &gt;= 2.7. Integration with NumPy is optional and requires NumPy &gt;= 1.6."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#overview",
    "href": "reticulate/doc/calling_python.html#overview",
    "title": "Calling Python from R",
    "section": "",
    "text": "The reticulate package provides an R interface to Python modules, classes, and functions. For example, this code imports the Python os module and calls some functions within it:\n\nlibrary(reticulate)\nos &lt;- import(\"os\")\nos$listdir(\".\")\n\n [1] \".git\"             \".gitignore\"       \".Rbuildignore\"    \".RData\"          \n [5] \".Rhistory\"        \".Rproj.user\"      \".travis.yml\"      \"appveyor.yml\"    \n [9] \"DESCRIPTION\"      \"docs\"             \"external\"         \"index.html\"      \n[13] \"index.Rmd\"        \"inst\"             \"issues\"           \"LICENSE\"         \n[17] \"man\"              \"NAMESPACE\"        \"NEWS.md\"          \"pkgdown\"         \n[21] \"R\"                \"README.md\"        \"reticulate.Rproj\" \"src\"             \n[25] \"tests\"            \"vignettes\"      \nFunctions and other data within Python modules and classes can be accessed via the $ operator (analogous to the way you would interact with an R list, environment, or reference class).\nThe reticulate package is compatible with all versions of Python &gt;= 2.7. Integration with NumPy is optional and requires NumPy &gt;= 1.6."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#python-version",
    "href": "reticulate/doc/calling_python.html#python-version",
    "title": "Calling Python from R",
    "section": "Python Version",
    "text": "Python Version\nBy default, reticulate uses the version of Python found on your PATH (i.e. Sys.which(\"python\")). The use_python() function enables you to specify an alternate version, for example:\nlibrary(reticulate)\nuse_python(\"/usr/local/bin/python\")\nThe use_virtualenv() and use_condaenv() functions enable you to specify versions of Python in virtual or conda environments, for example:\nlibrary(reticulate)\nuse_virtualenv(\"myenv\")\nSee the article on Python Version Configuration for additional details."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#python-packages",
    "href": "reticulate/doc/calling_python.html#python-packages",
    "title": "Calling Python from R",
    "section": "Python Packages",
    "text": "Python Packages\nYou can install any required Python packages using standard shell tools like pip and conda. Alternately, reticulate includes a set of functions for managing and installing packages within virtualenvs and Conda environments. See the article on Installing Python Packages for additional details."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#type-conversions",
    "href": "reticulate/doc/calling_python.html#type-conversions",
    "title": "Calling Python from R",
    "section": "Type Conversions",
    "text": "Type Conversions\nWhen calling into Python, R data types are automatically converted to their equivalent Python types. When values are returned from Python to R they are converted back to R types. Types are converted as follows:\n\n\n\n\n\n\n\n\nR\nPython\nExamples\n\n\n\n\nSingle-element vector\nScalar\n1, 1L, TRUE, \"foo\"\n\n\nMulti-element vector\nList\nc(1.0, 2.0, 3.0), c(1L, 2L, 3L)\n\n\nList of multiple types\nTuple\nlist(1L, TRUE, \"foo\")\n\n\nNamed list\nDict\nlist(a = 1L, b = 2.0), dict(x = x_data)\n\n\nMatrix/Array\nNumPy ndarray\nmatrix(c(1,2,3,4), nrow = 2, ncol = 2)\n\n\nData Frame\nPandas DataFrame\ndata.frame(x = c(1,2,3), y = c(\"a\", \"b\", \"c\"))\n\n\nFunction\nPython function\nfunction(x) x + 1\n\n\nRaw\nPython bytearray\nas.raw(c(1:10))\n\n\nNULL, TRUE, FALSE\nNone, True, False\nNULL, TRUE, FALSE\n\n\n\nIf a Python object of a custom class is returned then an R reference to that object is returned. You can call methods and access properties of the object just as if it was an instance of an R reference class."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#importing-modules",
    "href": "reticulate/doc/calling_python.html#importing-modules",
    "title": "Calling Python from R",
    "section": "Importing Modules",
    "text": "Importing Modules\nThe import() function can be used to import any Python module. For example:\n\ndifflib &lt;- import(\"difflib\")\ndifflib$ndiff(foo, bar)\n\nfilecmp &lt;- import(\"filecmp\")\nfilecmp$cmp(dir1, dir2)\n\nThe import_main() and import_builtins() functions give you access to the main module where code is executed by default and the collection of built in Python functions. For example:\n\nmain &lt;- import_main()\n\nbuiltins &lt;- import_builtins()\nbuiltins$print('foo')\n\nThe main module is generally useful if you have executed Python code from a file or string and want to get access to its results (see the section below for more details)."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#sourcing-scripts",
    "href": "reticulate/doc/calling_python.html#sourcing-scripts",
    "title": "Calling Python from R",
    "section": "Sourcing Scripts",
    "text": "Sourcing Scripts\nThe source_python() function will source a Python script and make the objects it creates available within an R environment (by default the calling environment). For example, consider the following Python script:\ndef add(x, y):\n  return x + y\nWe source it using the source_python() function and then can call the add() function directly from R:\n\nsource_python('add.py')\nadd(5, 10)\n\n[1] 15"
  },
  {
    "objectID": "reticulate/doc/calling_python.html#executing-code",
    "href": "reticulate/doc/calling_python.html#executing-code",
    "title": "Calling Python from R",
    "section": "Executing Code",
    "text": "Executing Code\nYou can execute Python code within the main module using the py_run_file and py_run_string functions. You can then access any objects created using the py object exported by reticulate:\n\nlibrary(reticulate)\n\npy_run_file(\"script.py\")\n\npy_run_string(\"x = 10\")\n\n# access the python main module via the 'py' object\npy$x"
  },
  {
    "objectID": "reticulate/doc/calling_python.html#object-conversion",
    "href": "reticulate/doc/calling_python.html#object-conversion",
    "title": "Calling Python from R",
    "section": "Object Conversion",
    "text": "Object Conversion\nBy default when Python objects are returned to R they are converted to their equivalent R types. However, if you’d rather make conversion from Python to R explicit and deal in native Python objects by default you can pass convert = FALSE to the import function. In this case Python to R conversion will be disabled for the module returned from import. For example:\n\n# import numpy and specify no automatic Python to R conversion\nnp &lt;- import(\"numpy\", convert = FALSE)\n\n# do some array manipulations with NumPy\na &lt;- np$array(c(1:4))\nsum &lt;- a$cumsum()\n\n# convert to R explicitly at the end\npy_to_r(sum)\n\nAs illustrated above, if you need access to an R object at end of your computations you can call the py_to_r() function explicitly."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#getting-help",
    "href": "reticulate/doc/calling_python.html#getting-help",
    "title": "Calling Python from R",
    "section": "Getting Help",
    "text": "Getting Help\nYou can print documentation on any Python object using the py_help() function. For example:\nos &lt;- import(\"os\")\npy_help(os$chdir)"
  },
  {
    "objectID": "reticulate/doc/calling_python.html#lists-tuples-and-dictionaries",
    "href": "reticulate/doc/calling_python.html#lists-tuples-and-dictionaries",
    "title": "Calling Python from R",
    "section": "Lists, Tuples, and Dictionaries",
    "text": "Lists, Tuples, and Dictionaries\nThe automatic conversion of R types to Python types works well in most cases, but occasionally you will need to be more explicit on the R side to provide Python the type it expects.\nFor example, if a Python API requires a list and you pass a single element R vector it will be converted to a Python scalar. To overcome this simply use the R list function explicitly:\nfoo$bar(indexes = list(42L))\nSimilarly, a Python API might require a tuple rather than a list. In that case you can use the tuple() function:\ntuple(\"a\", \"b\", \"c\")\nR named lists are converted to Python dictionaries however you can also explicitly create a Python dictionary using the dict() function:\ndict(foo = \"bar\", index = 42L)\nThis might be useful if you need to pass a dictionary that uses a more complex object (as opposed to a string) as its key."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#numeric-types-and-indexes",
    "href": "reticulate/doc/calling_python.html#numeric-types-and-indexes",
    "title": "Calling Python from R",
    "section": "Numeric Types and Indexes",
    "text": "Numeric Types and Indexes\nR and Python have different default numeric types. If you write 42 in R it is considered a floating point number whereas 42 in Python is considered an integer.\nThis means that when a Python API expects an integer, you need to be sure to use the L suffix within R. For example, if the foo function requires an integer as its index argument you would do this:\nfoo$bar(index = 42L)\nPython collections are addressed using 0-based indices rather than the 1-based indices you might be familiar with from R. So to address the first item of an array in R you would write:\nitems[[1]]\nWhereas if you are calling a method in Python via reticulate that takes an index you would write this to address the first item:\nitems$get(0L)\nNote the use of the 0-based index as well as the L to indicate t that the value is an integer."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#arrays",
    "href": "reticulate/doc/calling_python.html#arrays",
    "title": "Calling Python from R",
    "section": "Arrays",
    "text": "Arrays\nR matrices and arrays are converted automatically to and from NumPy arrays.\nWhen converting from R to NumPy, the NumPy array is mapped directly to the underlying memory of the R array (no copy is made). In this case, the NumPy array uses a column-based in memory layout that is compatible with R (i.e. Fortran style rather than C style). When converting from NumPy to R, R receives a column-ordered copy of the NumPy array.\nYou can also manually convert R arrays to NumPy using the np_array() function. For example, you might do this if you needed to create a NumPy array with C rather than Fortran style in-memory layout (for higher performance in row-oriented computations) or if you wanted to control the data type of the NumPy array more explicitly. Here are some example uses of np_array():\na &lt;- np_array(c(1:8), dtype = \"float16\")\na &lt;- np_array(c(1:8), order = \"C\")\nReasoning about arrays which use distinct in-memory orders can be tricky. The Arrays in R and Python article provides additional details.\nAlso, always remember that when calling NumPy methods array indices are 0 rather than 1 based and require the L suffix to indicate they are integers."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#data-frames",
    "href": "reticulate/doc/calling_python.html#data-frames",
    "title": "Calling Python from R",
    "section": "Data Frames",
    "text": "Data Frames\nR data frames can be automatically converted to and from Pandas DataFrames. By default, columns are converted using the same rules governing R array &lt;-&gt; NumPy array conversion, but a couple extensions are provided:\n\n\n\nR\nPython\n\n\n\n\nFactor\nCategorical Variable\n\n\nPOSIXt\nNumPy array with dtype = datetime64[ns]\n\n\n\nIf the R data frame has row names, the generated Pandas DataFrame will be re-indexed using those row names (and vice versa). Special handling is also available for a DatetimeIndex associated with a Pandas DataFrame; however, because R only supports character vectors for row names they are converted to character first.\n\nUsing Pandas nullable data types\nPandas has experimental support for nullable data types. Those data types have built-in support for missing values, represented by pd.NA and using them allows us to better represent R NA values.\nUsers can opt-in to use Pandas nullable data types instead of numpy arrays by setting the reticulate.pandas_use_nullable_dtypes to TRUE. For example:\ndf &lt;- data.frame(\n  int = c(NA, 1:4),\n  num = c(NA, rnorm(4)),\n  lgl = c(NA, rep(c(TRUE, FALSE), 2)),\n  string = c(NA, letters[1:4])\n)\noptions(reticulate.pandas_use_nullable_data_types = TRUE)\nr_to_py(df)\n#&gt;     int       num    lgl string\n#&gt; 0  &lt;NA&gt;      &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;\n#&gt; 1     1 -0.697855   True      a\n#&gt; 2     2 -0.253042  False      b\n#&gt; 3     3  0.385421   True      c\n#&gt; 4     4  0.519933  False      d"
  },
  {
    "objectID": "reticulate/doc/calling_python.html#sparse-matrices",
    "href": "reticulate/doc/calling_python.html#sparse-matrices",
    "title": "Calling Python from R",
    "section": "Sparse Matrices",
    "text": "Sparse Matrices\nSparse matrices created by Matrix R package can be converted Scipy CSC matrix, and vice versa. This is often useful when you want to pass sparse matrices to Python functions that accepts Scipy CSC matrix to take advantage of this format, such as efficient column slicing and fast matrix vector products.\nFor example, we first create a sparse matrix using Matrix::sparseMatrix():\nlibrary(Matrix)\nN &lt;- 5\ndgc_matrix &lt;- sparseMatrix(\n  i = sample(N, N),\n  j = sample(N, N),\n  x = runif(N),\n  dims = c(N, N))\nThe sparse matrix looks like this:\n&gt; dgc_matrix\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n                                                        \n[1,] 0.2264952 .          .          .         .        \n[2,] .         .          .          .         0.3927282\n[3,] .         .          .          0.9215908 .        \n[4,] .         .          0.01777771 .         .        \n[5,] .         0.05885743 .          .         . \nLet’s convert it to Scipy CSC matrix using r_to_py():\n&gt; csc_matrix &lt;- r_to_py(x)\n&gt; csc_matrix\n  (0, 0)    0.226495201467\n  (4, 1)    0.0588574311696\n  (3, 2)    0.0177777127828\n  (2, 3)    0.921590822982\n  (1, 4)    0.392728160601\nNote that the right-hand side contains the non-zero entries of the matrix while the left-hand side represents their locations in the matrix.\nWe can also use py_to_r() to convert the CSC matrix back to Matrix::dgCMatrix representation that can then be manipulated easily in R which is the same as the original sparse matrix that we created earlier using Matrix::sparseMatrix():\n&gt; py_to_r(csc_matrix)\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n                                                        \n[1,] 0.2264952 .          .          .         .        \n[2,] .         .          .          .         0.3927282\n[3,] .         .          .          0.9215908 .        \n[4,] .         .          0.01777771 .         .        \n[5,] .         0.05885743 .          .         ."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#with-contexts",
    "href": "reticulate/doc/calling_python.html#with-contexts",
    "title": "Calling Python from R",
    "section": "With Contexts",
    "text": "With Contexts\nThe R with generic function can be used to interact with Python context manager objects (in Python you use the with keyword to do the same). For example:\n\npy &lt;- import_builtins()\nwith(py$open(\"output.txt\", \"w\") %as% file, {\n  file$write(\"Hello, there!\")\n})\n\nThis example opens a file and ensures that it is automatically closed at the end of the with block. Note the use of the %as% operator to alias the object created by the context manager."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#iterators",
    "href": "reticulate/doc/calling_python.html#iterators",
    "title": "Calling Python from R",
    "section": "Iterators",
    "text": "Iterators\nIf a Python API returns an iterator or a generator, you can interact with it using the iterate() function. The iterate() function can be used to apply an R function to each item yielded by the iterator:\n\niterate(iter, print)\n\nIf you don’t pass a function to iterate the results will be collected into an R vector:\n\nresults &lt;- iterate(iter)\n\nNote that the Iterators will be drained of their values by iterate():\n\na &lt;- iterate(iter) # results are not empty\nb &lt;- iterate(iter) # results are empty since items have already been drained\n\n\nElement Level Iteration\nYou can also iterate on an element-by-element basis using the iter_next() function. For example:\n\nwhile (TRUE) {\n  item &lt;- iter_next(iter)\n  if (is.null(item))\n    break\n}\n\nBy default iter_next() will return NULL when the iteration is complete but you can provide a custom completed value it will be returned instead. For example:\n\nwhile (TRUE) {\n  item &lt;- iter_next(iter, completed = NA)\n  if (is.na(item))\n    break\n}\n\nNote that some iterators/generators in Python are infinite. In that case the caller will need custom logic to determine when to terminate the loop.\n\n\nGenerators\nPython generators are functions that implement the Python iterator protocol. Similarly, the reticulate generator() function enables you to create a Python iterator from an R function.\nIn Python, generators produce values using the yield keyword. In R, values are simply returned from the function. One benefit of the yield keyword is that it enables successive iterations to use the state of previous iterations. In R, this can be done by returning a function that mutates its enclosing environment via the &lt;&lt;- operator. For example:\n\n# define a generator function\nsequence_generator &lt;-function(start) {\n  value &lt;- start\n  function() {\n    value &lt;&lt;- value + 1\n    value\n  }\n}\n\n# convert the function to a python iterator\niter &lt;- py_iterator(sequence_generator(10))\n\nIf you want to indicate the end of the iteration, return NULL from the function:\n\nsequence_generator &lt;-function(start) {\n  value &lt;- start\n  function() {\n    value &lt;&lt;- value + 1\n    if (value &lt; 100)\n      value\n    else\n      NULL\n  }\n}\n\nNote that you can change the value that indicates the end of the iteration using the completed parameter (e.g. py_iterator(func, completed = NA))."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#functions",
    "href": "reticulate/doc/calling_python.html#functions",
    "title": "Calling Python from R",
    "section": "Functions",
    "text": "Functions\n\nSignatures\nBy default R functions are converted to Python with a generic signature (function(...)), where there’s neither keyword argument nor default values for arguments.\nFor example, below we apply r_to_py() to an R function and then we use inspect Python module to get the converted function’s argument spec. You can see that the signature of the wrapped function looks different than the original R function’s signature.\n&gt; inspect &lt;- import(\"inspect\")\n&gt; converted_func &lt;- r_to_py(function(a, b = 1.5) {})\n&gt; inspect$getargspec(converted_func)\nArgSpec(args=[], varargs='args', keywords='kwargs', defaults=None)\nThis default conversion typically works fine, however some Python libraries have strict checking on the function signatures of user provided callbacks. In these cases the generic function(...) signature will fail this checking.\nFor these cases you can use py_func() to wrap the R function so that the wrapped function has exactly the same signature as that of the original R function, e.g. one argument a without default value and another argument b with default value 1.5.\n&gt; wrapped_func &lt;- py_func(function(a, b = 1.5) {})\n&gt; inspect$getargspec(wrapped_func)\nArgSpec(args=['a', 'b'], varargs=None, keywords=None, defaults=(1.5,))\nNote that the signature of the R function must not contain esoteric Python-incompatible constructs. For example, we cannot have R function with signature like function(a = 1, b) since Python function requires that arguments without default values appear before arguments with default values.\n\n\nBackground Threads\nIn some cases Python libraries will invoke callbacks on a Python background thread. Since R code must run on the main thread, this won’t work by default when you pass an R function as a callback.\nTo work around this, you can use py_main_thread_func(), which will provide a special wrapper for your R function that ensures it will only be called on the main thread."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#advanced",
    "href": "reticulate/doc/calling_python.html#advanced",
    "title": "Calling Python from R",
    "section": "Advanced",
    "text": "Advanced\nThere are several more advanced functions available that are useful principally when creating high level R interfaces for Python libraries.\n\nPython Objects\nTypically interacting with Python objects from R involves using the $ operator to access whatever properties for functions of the object you need. When using the $, Python objects are automatically converted to their R equivalents when possible. The following functions enable you to interact with Python objects at a lower level (e.g. no conversion to R is done unless you explicitly call the py_to_r function):\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\npy_has_attr()\nCheck if an object has a specified attribute.\n\n\npy_get_attr()\nGet an attribute of a Python object.\n\n\npy_set_attr()\nSet an attribute of a Python object.\n\n\npy_list_attributes()\nList all attributes of a Python object.\n\n\npy_len()\nLength of Python object.\n\n\npy_call()\nCall a Python callable object with the specified arguments.\n\n\npy_to_r()\nConvert a Python object to its R equivalent\n\n\nr_to_py()\nConvert an R object to its Python equivalent\n\n\n\n\n\nPickle\nYou can save and load Python objects (via pickle) using the py_save_object and py_load_object functions:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\npy_save_object()\nSave a Python object to a file with pickle.\n\n\npy_load_object()\nLoad a previously saved Python object from a file.\n\n\n\n\n\nConfiguration\nThe following functions enable you to query for information about the Python configuration available on the current system.\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\npy_available()\nCheck whether a Python interface is available on this system.\n\n\npy_numpy_available()\nCheck whether the R interface to NumPy is available (requires NumPy &gt;= 1.6)\n\n\npy_module_available()\nCheck whether a Python module is available on this system.\n\n\npy_config()\nGet information on the location and version of Python in use.\n\n\n\n\n\nOutput Control\nThese functions enable you to capture or suppress output from Python:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\npy_capture_output()\nCapture Python output for the specified expression and return it as an R character vector.\n\n\npy_suppress_warnings()\nExecute the specified expression, suppressing the display Python warnings.\n\n\n\n\n\nMiscellaneous\nThe functions provide miscellaneous other lower-level capabilities:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\npy_set_seed()\nSet Python and NumPy random seeds.\n\n\npy_unicode()\nConvert a string to a Python unicode object.\n\n\npy_str(), py_repr()\nGet the string representation of Python object.\n\n\npy_id()\nGet a unique identifier for a Python object\n\n\npy_is_null_xptr()\nCheck whether a Python object is a null externalptr.\n\n\npy_validate_xptr()\nCheck whether a Python object is a null externalptr and throw an error if it is."
  },
  {
    "objectID": "reticulate/doc/calling_python.html#learning-more",
    "href": "reticulate/doc/calling_python.html#learning-more",
    "title": "Calling Python from R",
    "section": "Learning More",
    "text": "Learning More\nThe following articles cover additional aspects of using reticulate:\n\nR Markdown Python Engine\nPython Version Configuration\nInstalling Python Packages\nUsing reticulate in an R Package\nArrays in R and Python"
  },
  {
    "objectID": "reticulate/doc/python_dependencies.html",
    "href": "reticulate/doc/python_dependencies.html",
    "title": "Managing an R Package’s Python Dependencies",
    "section": "",
    "text": "If you’re writing an R package that uses reticulate as an interface to a Python session, you likely also need one or more Python packages installed on the user’s machine for your package to function. In addition, you’d likely prefer to insulate users from details around how Python + reticulate are configured as much as possible. This vignette documents a few approaches for accomplishing these goals."
  },
  {
    "objectID": "reticulate/doc/python_dependencies.html#creating-a-pit-of-success",
    "href": "reticulate/doc/python_dependencies.html#creating-a-pit-of-success",
    "title": "Managing an R Package’s Python Dependencies",
    "section": "Creating a Pit Of Success",
    "text": "Creating a Pit Of Success\nOverall, the goal of an R package author using reticulate is to create a default experience that works reliably and doesn’t require users to intervene or to have a sophisticated understanding of Python installation management. At the same time, it should also be easy to adjust the default behavior. There are two key questions to keep in mind:\n\nWhat will the default behavior be when the user expresses no preference for any specific Python installation, and\nHow can users express a preference for a specific Python installation that is satisfiable, (and why would they want to).\n\nPackages like tensorflow approach this task this by providing a helper function, tensorflow::install_tensorflow(), and documenting that users can call this function to prepare the environment. For example:\nlibrary(tensorflow)\ninstall_tensorflow()\n# use tensorflow\nAs a best practice, an R packages’ Python dependencies should default to installing in an isolated virtual environment specifically designated for the R package. This minimizes the risk of inadvertently disrupting another Python installation on the user’s system.\nAs an example, install_tensorflow() takes an argument with a default value: envname = \"r-tensorflow\". This default value ensures that install_tensorflow() will install into an environment named \"r-tensorflow\", optionally creating it as needed.\nThe counterpart to the default behavior of install_tensorflow() is the work that happens in tensorflow::.onLoad(), where the R package expresses a preference, on behalf of the user, to use the r-tensorflow environment if it exists. Inside the package, these two parts work together to create a “pit of success”:\ninstall_tensorflow &lt;- function(..., envname = \"r-tensorflow\") {\n  reticulate::py_install(\"tensorflow\", envname = envname, ...)\n}\n\n\n.onLoad &lt;- function(...) {\n  use_virtualenv(\"r-tensorflow\", required = FALSE)\n}\nThe R package:\n\nin .onLoad() expresses to reticulate a soft preference for an environment named “r-tensorflow”, and\nwith install_tensorflow(), provides a convenient way to make the optional hint in .onLoad() actionable, by actually creating the “r-tensorflow” environment.\n\nWith this setup, the default experience is for the user to call install_tensorflow() once (creating a “r-tensorflow” environment). Subsequently, calls to library(tensorflow) will cause reticulate to use the r-tensorflow environment, and for everything to “just-work”. The risk of disrupting another Python environment, or of this one being disrupting, is minimal, since the environment is designated for the R package. At the same time, if the environment is disrupted at some time later (perhaps because something with conflicting Python dependencies was manually installed), the user can easily revert to a working state by calling install_tensorflow().\nPython environments can occasionally get into a broken state when conflicting package versions are installed, and the most reliable way to get back to a working state is to delete the environment and start over with a fresh one. For this reason, install_tensorflow() removes any pre-existing “r-tensorflow” python environments first. Deleting a Python environment however is not something to be done lightly, so the default is to only delete the default “r-tensorflow” environment. Here is an example of the helper install_tensorflow() with the “reset” behavior.\n#' @importFrom reticulate py_install virtualenv_exists virtualenv_remove\ninstall_tensorflow &lt;-\n  function(...,\n           envname = \"r-tensorflow\",\n           new_env = identical(envname, \"r-tensorflow\")) {\n\n  if(new_env && virtualenv_exists(envname))\n    virtualenv_remove(envname)\n\n  py_install(packages = \"tensorflow\", envname = envname, ...)\n}"
  },
  {
    "objectID": "reticulate/doc/python_dependencies.html#managing-multiple-package-dependencies.",
    "href": "reticulate/doc/python_dependencies.html#managing-multiple-package-dependencies.",
    "title": "Managing an R Package’s Python Dependencies",
    "section": "Managing Multiple Package Dependencies.",
    "text": "Managing Multiple Package Dependencies.\nOne drawback of the isolated-package-environments approach is that if multiple R packages using reticulate are in use, then those packages won’t all be able to use their preferred Python environment in the same R session (since there can only be one active Python environment at a time within an R session). To resolve this, users will have to take a slightly more active role in managing their python environments. However, this can be as simple as supplying a unique environment name.\nThe most straightforward approach is for users to create a dedicated python environment for a specific project. For example, a user can create a virtual environment in the project directory, like this:\nenvname &lt;- \"./venv\"\ntensorflow::install_tensorflow(envname = envname)\npysparklyr::install_pyspark(envname = envname)\nAs described in the Order of Python Discovery guide, reticulate will automatically discover and use a Python virtual environment in the current working directory like this. Alternatively, if the environment exists outside the project directory, the user could then place a .Renviron or .Rprofile file in the project directory, ensuring that reticulate will use always use the python configured for that project. For example, an .Renviron file in the project directory could contain:\nRETICULATE_PYTHON_ENV=~/my/project/venv\nOr a .Rprofile in the project directory could contain:\nSys.setenv(\"RETICULATE_PYTHON_ENV\" = \"~/my/project/venv\")\nThis approach minimizes the risk that an existing, already working, Python environment will accidentally be broken by installing packages, due to inadvertently upgrading or downgrading other Python packages already installed in the environment.\nAnother approach is for users to install your R packages Python dependencies into another Python environment that is already on the search path. For example, users can opt-in to installing into the default r-reticulate venv:\ntensorflow::install_tensorflow(envname = \"r-reticulate\")\nOr they can install one packages dependencies into another packages default environment. For example, installing spark into the default “r-tensorflow” environment:\ntensorflow::install_tensorflow() # creates an \"r-tensorflow\" env\npysparklyr::install_pyspark(envname = \"r-tensorflow\")\nThis approach—exporting a installation helper function that defaults to a particular environment, and a hint in .onLoad() to use that environment—is one way to create a “pit-of-success”. It encourages a default workflow that is robust and reliable, especially for users not-yet familiar with the mechanics of Python installation management. At the same time, an installation helper function empowers users to manage Python environments through simply providing an environment name. It makes it easy to combine dependencies of multiple R packages, and, should anything go wrong due to conflicting Python dependencies, it also provides a straightforward way to revert to a working state at any time, by calling the helper function without arguments."
  },
  {
    "objectID": "reticulate/doc/python_dependencies.html#automatic-configuration",
    "href": "reticulate/doc/python_dependencies.html#automatic-configuration",
    "title": "Managing an R Package’s Python Dependencies",
    "section": "Automatic Configuration",
    "text": "Automatic Configuration\nAn alternative approach to the one describe above it to do automatic configuration. It’s possible for client packages to declare their Python dependencies in such a way that they are automatically installed in the currently activated Python environment. This is a maximally convenient approach; when it works it can feel a little bit magical, but it is also potentially dangerous and can result in frustration if something goes wrong. You can opt-in to this behavior as a package author through your packages DESCRIPTION file, with the use of the Config/reticulate field.\nWith automatic configuration, reticulate envisions a world wherein different R packages wrapping Python packages can live together in the same Python environment / R session. This approach only works when the Python packages being wrapped don’t have conflicting dependencies.\nYou must be a judge of the Python dependencies your R package requires–if automatically bootstrapping an installation of the python package into the users active python environment, whatever it may contain, is a safe action to perform by default. For example, this is most likely a safe action for a Python package like “requests”, but perhaps not a safe choice for a frequently updated package with many dependencies, like torch or tensorflow (e.g., it’s not uncommon for torch and tensorflow to have conflicting version requirements for dependencies like numpy or cuda). Keep in mind that, unlike CRAN, PyPI does not perform any compatibility or consistency checks across the package repository.\n\nUsing Config/reticulate\nAs a package author, you can opt-in to automatic configuration like this. For example, if we had a package rscipy that acted as an interface to the SciPy Python package, we might use the following DESCRIPTION:\nPackage: rscipy\nTitle: An R Interface to scipy\nVersion: 1.0.0\nDescription: Provides an R interface to the Python package scipy.\nConfig/reticulate/autoconfigure:\n  list(\n    packages = list(\n      list(package = \"scipy\")\n    )\n  )\n&lt; ... other fields ... &gt;\n\n\nInstallation\nWith this, reticulate will take care of automatically configuring a Python environment for the user when the rscipy package is loaded and used (i.e. it’s no longer necessary to provide the user with a special install_tensorflow() type function, though it’s still recommended to do so).\nSpecifically, after the rscipy package is loaded, the following will occur:\n\nUnless the user has explicitly instructed reticulate to use an existing Python environment, reticulate will prompt the user to download and install Miniconda (if necessary).\nAfter this, when the Python session is initialized by reticulate, all declared dependencies of loaded packages in Config/reticulate will be discovered.\nThese dependencies will then be installed into an appropriate Conda environment, as provided by the Miniconda installation.\n\nIn this case, the end user workflow will be exactly as with an R package that has no Python dependencies:\nlibrary(rscipy)\n# use the package\nIf the user has no compatible version of Python available on their system, they will be prompted to install Miniconda. If they do have Python already, then the required Python packages (in this case scipy) will be installed in the standard shared environment for R sessions (typically a virtual environment, or a Conda environment named “r-reticulate”).\nIn effect, users have to pay a one-time, mostly-automated initialization cost in order to use your package, and then things will then work as any other R package would. In particular, users are otherwise insulated from details as to how reticulate works.\n\n\n.onLoad Configuration\nIn some cases, a user may try to load your package after Python has already been initialized. To ensure that reticulate can still configure the active Python environment, you can include the code:\n.onLoad &lt;- function(libname, pkgname) {\n  reticulate::configure_environment(pkgname)\n}\nThis will instruct reticulate to immediately try to configure the active Python environment, installing any required Python packages as necessary."
  },
  {
    "objectID": "reticulate/doc/python_dependencies.html#versions",
    "href": "reticulate/doc/python_dependencies.html#versions",
    "title": "Managing an R Package’s Python Dependencies",
    "section": "Versions",
    "text": "Versions\nThe goal of these mechanisms is to allow easy interoperability between R packages that have Python dependencies, as well as to minimize specialized version/configuration steps for end-users. To that end, reticulate will (by default) track an older version of Python than the current release, giving Python packages time to adapt as is required. Python 2 will not be supported.\nTools for breaking these rules are not yet implemented, but will be provided as the need arises."
  },
  {
    "objectID": "reticulate/doc/python_dependencies.html#format",
    "href": "reticulate/doc/python_dependencies.html#format",
    "title": "Managing an R Package’s Python Dependencies",
    "section": "Format",
    "text": "Format\nDeclared Python package dependencies should have the following format:\n\npackage: The name of the Python package.\nversion: The version of the package that should be installed. When left unspecified, the latest-available version will be installed. This should only be set in exceptional cases – for example, if the most recently-released version of a Python package breaks compatibility with your package (or other Python packages) in a fundamental way. If multiple R packages request different versions of a particular Python package, reticulate will signal a warning.\npip: Whether this package should be retrieved from the PyPI with pip, or (if FALSE) from the Anaconda repositories.\n\nFor example, we could change the Config/reticulate directive from above to specify that scipy [1.3.0] be installed from PyPI (with pip):\nConfig/reticulate:\n  list(\n    packages = list(\n      list(package = \"scipy\", version = \"1.3.0\", pip = TRUE)\n    )\n  )"
  },
  {
    "objectID": "reticulate/doc/python_primer.html",
    "href": "reticulate/doc/python_primer.html",
    "title": "Primer on Python for R Users",
    "section": "",
    "text": "library(reticulate)"
  },
  {
    "objectID": "reticulate/doc/python_primer.html#primer-on-python-for-r-users",
    "href": "reticulate/doc/python_primer.html#primer-on-python-for-r-users",
    "title": "Primer on Python for R Users",
    "section": "Primer on Python for R users",
    "text": "Primer on Python for R users\nYou may find yourself wanting to read and understand some Python, or even port some Python to R. This guide is designed to enable you to do these tasks as quickly as possible. As you’ll see, R and Python are similar enough that this is possible without necessarily learning all of Python. We start with the basics of container types and work up to the mechanics of classes, dunders, the iterator protocol, the context protocol, and more!\n\nWhitespace\nWhitespace matters in Python. In R, expressions are grouped into a code block with {}. In Python, that is done by making the expressions share an indentation level. For example, an expression with an R code block might be:\n\nif (TRUE) {\n  cat(\"This is one expression. \\n\")\n  cat(\"This is another expression. \\n\")\n}\n#&gt; This is one expression. \n#&gt; This is another expression.\n\nThe equivalent in Python:\n\nif True:\n  print(\"This is one expression.\")\n  print(\"This is another expression.\")\n#&gt; This is one expression.\n#&gt; This is another expression.\n\nPython accepts tabs or spaces as the indentation spacer, but the rules get tricky when they’re mixed. Most style guides suggest (and IDE’s default to) using spaces only.\n\n\nContainer Types\nIn R, the list() is a container you can use to organize R objects. R’s list() is feature packed, and there is no single direct equivalent in Python that supports all the same features. Instead there are (at least) 4 different Python container types you need to be aware of: lists, dictionaries, tuples, and sets.\n\nLists\nPython lists are typically created using bare brackets []. The Python built-in list() function is more of a coercion function, closer in spirit to R’s as.list(). The most important thing to know about Python lists is that they are modified in place. Note in the example below that y reflects the changes made to x, because the underlying list object which both symbols point to is modified in place.\n\nx = [1, 2, 3]\ny = x    # `y` and `x` now refer to the same list!\nx.append(4)\nprint(\"x is\", x)\n#&gt; x is [1, 2, 3, 4]\nprint(\"y is\", y)\n#&gt; y is [1, 2, 3, 4]\n\nOne Python idiom that might be concerning to R users is that of growing lists through the append() method. Growing lists in R is typically slow and best avoided. But because Python’s list are modified in place (and a full copy of the list is avoided when appending items), it is efficient to grow Python lists in place.\nSome syntactic sugar around Python lists you might encounter is the usage of + and * with lists. These are concatenation and replication operators, akin to R’s c() and rep().\n\nx = [1]\nx\n#&gt; [1]\nx + x\n#&gt; [1, 1]\nx * 3\n#&gt; [1, 1, 1]\n\nYou can index into lists with integers using trailing [], but note that indexing is 0-based.\n\nx = [1, 2, 3]\nx[0]\n#&gt; 1\nx[1]\n#&gt; 2\nx[2]\n#&gt; 3\n\ntry:\n  x[3]\nexcept Exception as e:\n  print(e)\n#&gt; list index out of range\n\nWhen indexing, negative numbers count from the end of the container.\n\nx = [1, 2, 3]\nx[-1]\n#&gt; 3\nx[-2]\n#&gt; 2\nx[-3]\n#&gt; 1\n\nYou can slice ranges of lists using the : inside brackets. Note that the slice syntax is not inclusive of the end of the slice range. You can optionally also specify a stride.\n\nx = [1, 2, 3, 4, 5, 6]\nx[0:2] # get items at index positions 0, 1\n#&gt; [1, 2]\nx[1:]  # get items from index position 1 to the end\n#&gt; [2, 3, 4, 5, 6]\nx[:-2] # get items from beginning up to the 2nd to last.\n#&gt; [1, 2, 3, 4]\nx[:]   # get all the items (idiom used to copy the list so as not to modify in place)\n#&gt; [1, 2, 3, 4, 5, 6]\nx[::2] # get all the items, with a stride of 2\n#&gt; [1, 3, 5]\nx[1::2] # get all the items from index 1 to the end, with a stride of 2\n#&gt; [2, 4, 6]\n\n\n\nTuples\nTuples behave like lists, except they are not mutable, and they don’t have the same modify-in-place methods like append(). They are typically constructed using bare (), but parentheses are not strictly required, and you may see an implicit tuple being defined just from a comma separated series of expressions. Because parentheses can also be used to specify order of operations in expressions like (x + 3) * 4, a special syntax is required to define tuples of length 1: a trailing comma. Tuples are most commonly encountered in functions that take a variable number of arguments.\n\nx = (1, 2) # tuple of length 2\ntype(x)\n#&gt; &lt;class 'tuple'&gt;\nlen(x)\n#&gt; 2\nx\n#&gt; (1, 2)\n\nx = (1,) # tuple of length 1\ntype(x)\n#&gt; &lt;class 'tuple'&gt;\nlen(x)\n#&gt; 1\nx\n#&gt; (1,)\n\nx = () # tuple of length 0\nprint(f\"{type(x) = }; {len(x) = }; {x = }\")\n#&gt; type(x) = &lt;class 'tuple'&gt;; len(x) = 0; x = ()\n# example of an interpolated string literals\n\nx = 1, 2 # also a tuple\ntype(x)\n#&gt; &lt;class 'tuple'&gt;\nlen(x)\n#&gt; 2\n\nx = 1, # beware a single trailing comma! This is a tuple!\ntype(x)\n#&gt; &lt;class 'tuple'&gt;\nlen(x)\n#&gt; 1\n\n\nPacking and Unpacking\nTuples are the container that powers the packing and unpacking semantics in Python. Python provides the convenience of allowing you to assign multiple symbols in one expression. This is called unpacking.\nFor example:\n\nx = (1, 2, 3)\na, b, c = x\na\n#&gt; 1\nb\n#&gt; 2\nc\n#&gt; 3\n\n(You can access similar unpacking behavior from R using zeallot::`%&lt;-%`).\nTuple unpacking can occur in a variety of contexts, such as iteration:\n\nxx = ((\"a\", 1),\n      (\"b\", 2))\nfor x1, x2 in xx:\n  print(\"x1 = \", x1)\n  print(\"x2 = \", x2)\n#&gt; x1 =  a\n#&gt; x2 =  1\n#&gt; x1 =  b\n#&gt; x2 =  2\n\nIf you attempt to unpack a container to the wrong number of symbols, Python raises an error:\n\nx = (1, 2, 3)\na, b, c = x # success\na, b = x    # error, x has too many values to unpack\n#&gt; ValueError: too many values to unpack (expected 2)\na, b, c, d = x # error, x has not enough values to unpack\n#&gt; ValueError: not enough values to unpack (expected 4, got 3)\n\nIt is possible to unpack a variable number of arguments, using * as a prefix to a symbol. (You’ll see the * prefix again when we talk about functions)\n\nx = (1, 2, 3)\na, *the_rest = x\na\n#&gt; 1\nthe_rest\n#&gt; [2, 3]\n\nYou can also unpack nested structures:\n\nx = ((1, 2), (3, 4))\n(a, b), (c, d) = x\n\n\n\n\nDictionaries\nDictionaries are most similar to R environments. They are a container where you can retrieve items by name, though in Python the name (called a key in Python’s parlance) does not need to be a string like in R. It can be any Python object with a hash() method (meaning, it can be almost any Python object). They can be created using syntax like {key: value}. Like Python lists, they are modified in place. Note that r_to_py() converts R named lists to dictionaries.\n\nd = {\"key1\": 1,\n     \"key2\": 2}\nd2 = d\nd\n#&gt; {'key1': 1, 'key2': 2}\nd[\"key1\"]\n#&gt; 1\nd[\"key3\"] = 3\nd2 # modified in place!\n#&gt; {'key1': 1, 'key2': 2, 'key3': 3}\n\nLike R environments (and unlike R’s named lists), you cannot index into a dictionary with an integer to get an item at a specific index position. Dictionaries are unordered containers. (However—beginning with Python 3.7, dictionaries do preserve the item insertion order).\n\nd = {\"key1\": 1, \"key2\": 2}\nd[1] # error\n#&gt; KeyError: 1\n\nA container that closest matches the semantics of R’s named list is the OrderedDict, but that’s relatively uncommon in Python code so we don’t cover it further.\n\n\nSets\nSets are a container that can be used to efficiently track unique items or deduplicate lists. They are constructed using {val1, val2} (like a dictionary, but without :). Think of them as dictionary where you only use the keys. Sets have many efficient methods for membership operations, like intersection(), issubset(), union() and so on.\n\ns = {1, 2, 3}\ntype(s)\n#&gt; &lt;class 'set'&gt;\ns\n#&gt; {1, 2, 3}\n\ns.add(1)\ns\n#&gt; {1, 2, 3}\n\n\n\n\nIteration with for\nThe for statement in Python can be used to iterate over any kind of container.\n\nfor x in [1, 2, 3]:\n  print(x)\n#&gt; 1\n#&gt; 2\n#&gt; 3\n\nR has a relatively limited set of objects that can be passed to for. Python by comparison, provides an iterator protocol interface, which means that authors can define custom objects, with custom behavior that is invoked by for. (We’ll have an example for how to define a custom iterable when we get to classes). You may want to use a Python iterable from R using reticulate, so it’s helpful to peel back the syntactic sugar a little to show what the for statement is doing in Python, and how you can step through it manually.\nThere are two things that happen: first, an iterator is constructed from the supplied object. Then, the new iterator object is repeatedly called with next() until it is exhausted.\n\nl = [1, 2, 3]\nit = iter(l) # create an iterator object\nit\n#&gt; &lt;list_iterator object at 0x000001E8453E5300&gt;\n\n# call `next` on the iterator until it is exhausted:\nnext(it)\n#&gt; 1\nnext(it)\n#&gt; 2\nnext(it)\n#&gt; 3\nnext(it)\n#&gt; StopIteration\n\nIn R, you can use reticulate to step through an iterator the same way.\n\nlibrary(reticulate)\nl &lt;- r_to_py(list(1, 2, 3))\nit &lt;- as_iterator(l)\n\niter_next(it)\n#&gt; 1.0\niter_next(it)\n#&gt; 2.0\niter_next(it)\n#&gt; 3.0\niter_next(it, completed = \"StopIteration\")\n#&gt; [1] \"StopIteration\"\n\nIterating over dictionaries first requires understanding if you are iterating over the keys, values, or both. Dictionaries have methods that allow you to specify which.\n\nd = {\"key1\": 1, \"key2\": 2}\nfor key in d:\n  print(key)\n#&gt; key1\n#&gt; key2\n\nfor value in d.values():\n  print(value)\n#&gt; 1\n#&gt; 2\n\nfor key, value in d.items():\n  print(key, \":\", value)\n#&gt; key1 : 1\n#&gt; key2 : 2\n\n\nComprehensions\nComprehensions are special syntax that allow you to construct a container like a list or a dict, while also executing a small operation or single expression on each element. You can think of it as special syntax for R’s lapply.\nFor example:\n\nx = [1, 2, 3]\n\n# a list comprehension built from x, where you add 100 to each element\nl = [element + 100 for element in x]\nl\n#&gt; [101, 102, 103]\n\n# a dict comprehension built from x, where the key is a string.\n# Python's str() is like R's as.character()\nd = {str(element) : element + 100\n     for element in x}\nd\n#&gt; {'1': 101, '2': 102, '3': 103}\n\n\n\n\nDefining Functions with def\nPython functions are defined with the def statement. The syntax for specifying function arguments and default values is very similar to R.\n\ndef my_function(name = \"World\"):\n  print(\"Hello\", name)\n\nmy_function()\n#&gt; Hello World\nmy_function(\"Friend\")\n#&gt; Hello Friend\n\nThe equivalent R snippet would be\n\nmy_function &lt;- function(name = \"World\") {\n  cat(\"Hello\", name, \"\\n\")\n}\n\nmy_function()\n#&gt; Hello World\nmy_function(\"Friend\")\n#&gt; Hello Friend\n\nUnlike R functions, the last value in a function is not automatically returned. Python requires an explicit return statement.\n\ndef fn():\n  1\nprint(fn())\n#&gt; None\n\ndef fn():\n  return 1\nprint(fn())\n#&gt; 1\n\n(Note for advanced R users: Python has no equivalent of R’s argument “promises”. Function argument default values are evaluated once, when the function is constructed. This can be surprising if you define a Python function with a mutable object as a default argument value, like a Python list!)\n\ndef my_func(x = []):\n  x.append(\"was called\")\n  print(x)\n\nmy_func()\n#&gt; ['was called']\nmy_func()\n#&gt; ['was called', 'was called']\nmy_func()\n#&gt; ['was called', 'was called', 'was called']\n\nYou can also define Python functions that take a variable number of arguments, similar to ... in R. A notable difference is that R’s ... makes no distinction between named and unnamed arguments, but Python does. In Python, prefixing a single * captures unnamed arguments, and two ** signifies that keyword arguments are captured.\n\ndef my_func(*args, **kwargs):\n  print(\"args = \", args) # args is a tuple\n  print(\"kwargs = \", kwargs) # kwargs is a dictionary\n\nmy_func(1, 2, 3, a = 4, b = 5, c = 6)\n#&gt; args =  (1, 2, 3)\n#&gt; kwargs =  {'a': 4, 'b': 5, 'c': 6}\n\nWhereas the * and ** in a function definition signature pack arguments, in a function call they unpack arguments. Unpacking arguments in a function call is equivalent to using do.call() in R.\n\ndef my_func(a, b, c):\n  print(a, b, c)\n\nargs = (1, 2, 3)\nmy_func(*args)\n#&gt; 1 2 3\n\nkwargs = {\"a\": 1, \"b\": 2, \"c\": 3}\nmy_func(**kwargs)\n#&gt; 1 2 3\n\n\n\nDefining Classes with class\nOne could argue that in R, the preeminent unit of composition for code is the function, and in Python, it’s the class. You can be a very productive R user and never use R6, reference classes, or similar R equivalents to the object-oriented style of Python class’s.\nIn Python, however, understanding the basics of how class objects work is requisite knowledge, because class’s are how you organize and find methods in Python. (In contrast to R’s approach, where methods are found by dispatching from a generic). Fortunately, the basics of class’s are accessible.\nDon’t be intimidated if this is your first exposure to object oriented programming. We’ll start by building up a simple Python class for demonstration purposes.\n\nclass MyClass:\n  pass # `pass` means do nothing.\n\nMyClass\n#&gt; &lt;class '__main__.MyClass'&gt;\ntype(MyClass)\n#&gt; &lt;class 'type'&gt;\n\ninstance = MyClass()\ninstance\n#&gt; &lt;__main__.MyClass object at 0x000001E84556D280&gt;\ntype(instance)\n#&gt; &lt;class '__main__.MyClass'&gt;\n\nLike the def statement, the class statement binds a new callable symbol, MyClass. First note the strong naming convention, classes are typically CamelCase, and functions are typically snake_case. After defining MyClass, you can interact with it, and see that it has type 'type'. Calling MyClass() creates a new object instance of the class, which has type 'MyClass' (ignore the __main__. prefix for now). The instance prints with its memory address, which is a strong hint that it’s common to be managing many instances of a class, and that the instance is mutable (modified-in-place by default).\nIn the first example, we defined an empty class, but when we inspect it we see that it already comes with a bunch of attributes (dir() in Python is equivalent to names() in R):\n\ndir(MyClass)\n#&gt; ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']\n\n\nWhat are all the underscores?\nPython typically indicates that something is special by wrapping the name in double underscores. A special double-underscore-wrapped token is commonly called a “dunder”. “Special” is not a technical term, it just means that the token invokes a Python language feature. Some dunder tokens are merely ways code authors can plug into specific syntactic sugars, others are values provided by the interpreter that would be otherwise hard to acquire, yet others are for extending language interfaces (e.g., the iteration protocol), and finally, a small handful of dunders are truly complicated to understand. Fortunately, as an R user looking to use some Python features through reticulate, you only need to know about a few easy-to-understand dunders.\nThe most common dunder method you’ll encounter when reading Python code is __init__(). This is a function that is called when the class constructor is called, that is, when a class is instantiated. It is meant to initialize the new class instance. (In very sophisticated code bases, you may also encounter classes where __new__ is also defined, this is called before __init__).\n\nclass MyClass:\n\n  print(\"MyClass's definition body is being evaluated\")\n\n  def __init__(self):\n    print(self, \"is initializing\")\n#&gt; MyClass's definition body is being evaluated\n\nprint(\"MyClass is finished being created\")\n#&gt; MyClass is finished being created\n\ninstance = MyClass()\n#&gt; &lt;__main__.MyClass object at 0x000001E845515AC0&gt; is initializing\nprint(instance)\n#&gt; &lt;__main__.MyClass object at 0x000001E845515AC0&gt;\n\ninstance2 = MyClass()\n#&gt; &lt;__main__.MyClass object at 0x000001E84556E510&gt; is initializing\nprint(instance2)\n#&gt; &lt;__main__.MyClass object at 0x000001E84556E510&gt;\n\nA few things to note:\n\nthe class statement takes a code block that is defined by a common indentation level. The code block has the same exact semantics as any other expression that takes a code block, like if and def. The body of the class is evaluated only once, when the class constructor is first being created. Beware that any objects defined here are shared by all instances of the class!\n__init__ is just a normal function, defined with def like any other function. Except it’s inside the class body.\n__init__ take an argument: self. self is the class instance being initialized (note the identical memory address between self and instance). Also note that we didn’t provide self when call MyClass() to create the class instance, self was spliced into the function call by the interpreter.\n__init__ is called each time a new instance is created.\n\nFunctions defined inside a class code block are called methods, and the important thing to know about methods is that each time they are called from a class instance, the instance is spliced into the function call as the first argument. This applies to all functions defined in a class, including dunders. (The sole exception is if the function is decorated with something like @classmethod or @staticmethod).\n\nclass MyClass:\n  def a_method(self):\n    print(\"MyClass.a_method() was called with\", self)\n\ninstance = MyClass()\ninstance.a_method()\n#&gt; MyClass.a_method() was called with &lt;__main__.MyClass object at 0x000001E845429FA0&gt;\n\nMyClass.a_method()     # error, missing required argument `self`\n#&gt; TypeError: MyClass.a_method() missing 1 required positional argument: 'self'\nMyClass.a_method(instance) # identical to instance.a_method()\n#&gt; MyClass.a_method() was called with &lt;__main__.MyClass object at 0x000001E845429FA0&gt;\n\nOther dunder’s worth knowing about are:\n\n__getitem__: the function invoked when subsetting an instance with [ (Equivalent to defining a [ S3 method in R.\n__getattr__: the function invoked when subsetting with . (Equivalent to defining a $ S3 method in R.\n__iter__ and __next__: functions invoked by for.\n__call__: invoked when a class instance is called like a function (e.g., instance()).\n__bool__: invoked by if and while (equivalent to as.logical() in R, but returning only a scalar, not a vector).\n__repr__, __str__, functions invoked for formatting and pretty printing (akin to format(), dput(), and print() methods in R).\n__enter__ and __exit__: functions invoked by with.\nMany built-in Python functions are just sugar for invoking the dunder. For example: calling repr(x) is identical to x.__repr__(). Other builtins that are just sugar for invoking the dunder are next(), iter(), str(), list(), dict(), bool(), dir(), hash() and more!\n\n\n\nIterators, revisited\nNow that we have the basics of class, it’s time to revisit iterators. First, some terminology:\niterable: something that can be iterated over. Concretely, a class that defines an __iter__ method, whose job is to return an iterator.\niterator: something that iterates. Concretely, a class that defines a __next__ method, whose job is to return the next element each time it is called, and then raises a StopIteration exception once it’s exhausted.\nIt’s common to see classes that are both iterables and iterators, where the __iter__ method is just a stub that returns self.\nHere is a custom iterable / iterator implementation of Python’s range (similar to seq in R)\n\nclass MyRange:\n  def __init__(self, start, end):\n    self.start = start\n    self.end = end\n\n  def __iter__(self):\n    # reset our counter.\n    self._index = self.start - 1\n    return self\n\n  def __next__(self):\n    if self._index &lt; self.end:\n      self._index += 1 # increment\n      return self._index\n    else:\n      raise StopIteration\n\nfor x in MyRange(1, 3):\n  print(x)\n#&gt; 1\n#&gt; 2\n#&gt; 3\n\n# doing what `for` does, but manually\nr = MyRange(1, 3)\nit = iter(r)\nnext(it)\n#&gt; 1\nnext(it)\n#&gt; 2\nnext(it)\n#&gt; 3\nnext(it)\n#&gt; StopIteration\n\n\n\n\nDefining Generators with yield.\nGenerators are special Python functions that contain one or more yield statements. As soon as yield is included in a code block passed to def, the semantics change substantially. You’re no longer defining a mere function, but a generator constructor! In turn, calling a generator constructor creates a generator object, which is just another type of iterator.\nHere is an example:\n\ndef my_generator_constructor():\n  yield 1\n  yield 2\n  yield 3\n\n# At first glance it presents like a regular function\nmy_generator_constructor\n#&gt; &lt;function my_generator_constructor at 0x000001E8455B5EE0&gt;\ntype(my_generator_constructor)\n#&gt; &lt;class 'function'&gt;\n\n# But calling it returns something special, a 'generator object'\nmy_generator = my_generator_constructor()\nmy_generator\n#&gt; &lt;generator object my_generator_constructor at 0x000001E84548A140&gt;\ntype(my_generator)\n#&gt; &lt;class 'generator'&gt;\n\n# The generator object is both an iterable and an iterator\n# it's __iter__ method is just a stub that returns `self`\niter(my_generator) == my_generator == my_generator.__iter__()\n#&gt; True\n\n# step through it like any other iterator\nnext(my_generator)\n#&gt; 1\nmy_generator.__next__() # next() is just sugar for calling the dunder\n#&gt; 2\nnext(my_generator)\n#&gt; 3\nnext(my_generator)\n#&gt; StopIteration\n\nEncountering yield is like hitting the pause button on a functions execution, it preserves the state of everything in the function body and returns control to whatever is iterating over the generator object. Calling next() on the generator object resumes execution of the function body until the next yield is encountered, or the function finishes.\n\n\nIteration closing remarks\nIteration is deeply baked into the Python language, and R users may be surprised by how things in Python are iterable, iterators, or powered by the iterator protocol under the hood. For example, the built-in map() (equivalent to R’s lapply()) yields an iterator, not a list. Similarly, a tuple comprehension like (elem for elem in x) produces an iterator. Most features dealing with files are iterators, and so on.\nAny time you find an iterator inconvenient, you can materialize all the elements into a list using the Python built-in list(), or reticulate::iterate() in R. Also, if you like the readability of for, you can utilize similar semantics to Python’s for using coro::loop().\n\n\nimport and Modules\nIn R, authors can bundle their code into shareable extensions called R packages, and R users can access objects from R packages via library() or ::. In Python, authors bundle code into modules, and users access modules using import. Consider the line:\n\nimport numpy\n\nThis statement has Python go out to the file system, find an installed Python module named ‘numpy’, load it (commonly meaning: evaluate its __init__.py file and construct a module type), and bind it to the symbol numpy.\nThe closest equivalent to this in R might be:\n\ndplyr &lt;- loadNamespace(\"dplyr\")\n\n\nWhere are modules found?\nIn Python, the file system locations where modules are searched can be accessed (and modified) from the list found at sys.path. This is Python’s equivalent to R’s .libPaths(). sys.path will typically contain paths to the current working directory, the Python installation which contains the built-in standard library, administrator installed modules, user installed modules, values from environment variables like PYTHONPATH, and any modifications made directly to sys.path by other code in the current Python session (though this is relatively uncommon in practice).\n\nimport sys\nsys.path\n#&gt; ['', 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\.venv\\\\Scripts', 'C:\\\\Users\\\\C25Swayam.Singh\\\\AppData\\\\Local\\\\R\\\\cache\\\\R\\\\renv\\\\cache\\\\v5\\\\R-4.3\\\\x86_64-w64-mingw32\\\\reticulate\\\\1.36.1\\\\e037fb5dc364efdaf616eb6bc05aaca2\\\\reticulate\\\\config', 'C:\\\\Users\\\\C25Swayam.Singh\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\python312.zip', 'C:\\\\Users\\\\C25Swayam.Singh\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\DLLs', 'C:\\\\Users\\\\C25Swayam.Singh\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib', 'C:\\\\Users\\\\C25Swayam.Singh\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312', 'C:\\\\Users\\\\C25SWA~1.SIN\\\\Desktop\\\\FINALP~1\\\\VENV~1', 'C:\\\\Users\\\\C25SWA~1.SIN\\\\Desktop\\\\FINALP~1\\\\VENV~1\\\\Lib\\\\site-packages', 'C:\\\\Users\\\\C25SWA~1.SIN\\\\Desktop\\\\FINALP~1\\\\VENV~1\\\\Lib\\\\site-packages\\\\win32', 'C:\\\\Users\\\\C25SWA~1.SIN\\\\Desktop\\\\FINALP~1\\\\VENV~1\\\\Lib\\\\site-packages\\\\win32\\\\lib', 'C:\\\\Users\\\\C25SWA~1.SIN\\\\Desktop\\\\FINALP~1\\\\VENV~1\\\\Lib\\\\site-packages\\\\Pythonwin', 'C:\\\\Users\\\\C25Swayam.Singh\\\\AppData\\\\Local\\\\R\\\\cache\\\\R\\\\renv\\\\cache\\\\v5\\\\R-4.3\\\\x86_64-w64-mingw32\\\\reticulate\\\\1.36.1\\\\e037fb5dc364efdaf616eb6bc05aaca2\\\\reticulate\\\\python', 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\.venv\\\\DLLs', 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\.venv\\\\Lib', 'C:\\\\Users\\\\C25Swayam.Singh\\\\AppData\\\\Local\\\\Programs\\\\R\\\\R-4.3.3\\\\bin\\\\x64', 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\.venv', 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\.venv\\\\Lib\\\\site-packages', 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\.venv\\\\Lib\\\\site-packages\\\\win32', 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\.venv\\\\Lib\\\\site-packages\\\\win32\\\\lib', 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\.venv\\\\Lib\\\\site-packages\\\\Pythonwin']\n\nYou can inspect where a module was loaded from by accessing the dunder __path__ or __file__ (especially useful when troubleshooting installation issues):\n\nimport os\nos.__file__\n#&gt; 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\.venv\\\\Lib\\\\os.py'\nnumpy.__path__\n#&gt; ['C:\\\\Users\\\\C25SWA~1.SIN\\\\Desktop\\\\FINALP~1\\\\VENV~1\\\\Lib\\\\site-packages\\\\numpy']\n\nOnce a module is loaded, you can access symbols from the module using . (equivalent to ::, or maybe $.environment, in R).\n\nnumpy.abs(-1)\n#&gt; 1\n\nThere is also special syntax for specifying the symbol a module is bound to upon import, and for importing only some specific symbols.\n\nimport numpy        # import\nimport numpy as np  # import and bind to a custom symbol `np`\nnp is numpy         # test for identicalness, similar to identical(np, numpy)\n#&gt; True\n\nfrom numpy import abs # import only `numpy.abs`, bind it to `abs`\nabs is numpy.abs\n#&gt; True\n\nfrom numpy import abs as abs2 # import only `numpy.abs`, bind it to `abs2`\nabs2 is numpy.abs\n#&gt; True\n\nIf you’re looking for the Python equivalent of R’s library(), which makes all of a package’s exported symbols available, it might be using import with a * wildcard, though it’s relatively uncommon to do so. The * wildcard will expand to include all the symbols in module, or all the symbols listed in __all__, if it is defined.\n\nfrom numpy import *\n\nPython doesn’t make a distinction like R does between package exported and internal symbols. In Python, all module symbols are equal, though there is the naming convention that intended-to-be-internal symbols are prefixed with a single leading underscore. (Two leading underscores invoke an advanced language feature called “name mangling”, which is outside the scope of this introduction).\n\n\n\nIntegers and Floats\nR users generally don’t need to be aware of the difference between integers and floating point numbers, but that’s not the case in Python. If this is your first exposure to numeric data types, here are the essentials:\n\ninteger types can only represent whole numbers like 1 or 2, not floating point numbers like 1.2.\nfloating-point types can represent any number, but with some degree of imprecision.\n\nIn R, writing a bare literal number like 12 produces a floating point type, whereas in Python, it produces an integer. You can produce an integer literal in R by appending an L, as in 12L. Many Python functions expect integers, and will error when provided a float.\nFor example, say we have a Python function that expects an integer:\n\ndef a_strict_Python_function(x):\n  assert isinstance(x, int), \"x is not an int\"\n  print(\"Yay! x was an int\")\n\nWhen calling it from R, you must be sure to call it with an integer:\n\nlibrary(reticulate)\npy$a_strict_Python_function(3)             # error\n#&gt; x is not an int\npy$a_strict_Python_function(3L)            # success\n#&gt; Yay! x was an int\npy$a_strict_Python_function(as.integer(3)) # success\n#&gt; Yay! x was an int\n\n\n\nWhat about R vectors?\nR is a language designed for numerical computing first. Numeric vector data types are baked deep into the R language, to the point that the language doesn’t even distinguish scalars from vectors. By comparison, numerical computing capabilities in Python are generally provided by third party packages (modules, in Python parlance).\nIn Python, the numpy module is most commonly used to handle contiguous arrays of data. The closest equivalent to an R numeric vector is a numpy array, or sometimes, a list of scalar numbers (some Pythonistas might argue for array.array() here, but that’s so rarely encountered in actual Python code we don’t mention it further).\nTeaching the NumPy interface is beyond the scope of this primer, but it’s worth pointing out some potential tripping hazards for users accustomed to R arrays:\n\nWhen indexing into multidimensional numpy arrays, trailing dimensions can be omitted and are implicitly treated as missing. The consequence is that iterating over arrays means iterating over the first dimension. For example, this iterates over the rows of a matrix.\n\n\nimport numpy as np\nm = np.arange(12).reshape((3,4))\nm\n#&gt; array([[ 0,  1,  2,  3],\n#&gt;        [ 4,  5,  6,  7],\n#&gt;        [ 8,  9, 10, 11]])\nm[0, :] # first row\n#&gt; array([0, 1, 2, 3])\nm[0]    # also first row\n#&gt; array([0, 1, 2, 3])\n\nfor row in m:\n  print(row)\n#&gt; [0 1 2 3]\n#&gt; [4 5 6 7]\n#&gt; [ 8  9 10 11]\n\n\nMany numpy operations modify the array in place! This is surprising to R users, who are used to the convenience and safety of R’s copy-on-modify semantics. Unfortunately, there is no simple scheme or naming convention you can rely on to quickly determine if a particular method modifies in-place or creates a new array copy. The only reliable way is to consult the documentation, and conduct small experiments at the reticulate::repl_python().\n\n\n\nDecorators\nDecorators are just functions that take a function as an argument, and then typically returns another function. Any function can be invoked as a decorator with the @ syntax, which is just sugar for this simple action:\n\ndef my_decorator(func):\n  func.x = \"a decorator modified this function by adding an attribute `x`\"\n  return func\n\ndef my_function(): pass\nmy_function = my_decorator(my_function)\n\n# @ is just fancy syntax for the above two lines\n@my_decorator\ndef my_function(): pass\n\nOne decorator you might encounter frequently is:\n\n@property, which automatically calls a class method when the attribute is accessed (similar to makeActiveBinding() in R).\n\n\n\nwith and context management\nAny object that defines __enter__ and __exit__ methods implements the “context” protocol, and can be passed to with. For example, here is a custom implementation of a context manager that temporarily changes the current working directory (equivalent to R’s withr::with_dir())\n\nfrom os import getcwd, chdir\n\nclass wd_context:\n  def __init__(self, wd):\n    self.new_wd = wd\n\n  def __enter__(self):\n    self.original_wd = getcwd()\n    chdir(self.new_wd)\n\n  def __exit__(self, *args):\n    # __exit__ takes some additional argument that are commonly ignored\n    chdir(self.original_wd)\n\n\ngetcwd()\n#&gt; 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\reticulate\\\\doc'\nwith wd_context(\"..\"):\n  print(\"in the context, wd is:\", getcwd())\n#&gt; in the context, wd is: C:\\Users\\C25Swayam.Singh\\Desktop\\Final Project\\reticulate\ngetcwd()\n#&gt; 'C:\\\\Users\\\\C25Swayam.Singh\\\\Desktop\\\\Final Project\\\\reticulate\\\\doc'\n\n\n\nLearning More\nHopefully, this short primer to Python has provided a good foundation for confidently reading Python documentation and code, and using Python modules from R via reticulate. Of course, there is much, much more to learn about Python. Googling questions about Python reliably brings up pages of results, but not always sorted in order of most useful. Blog posts and tutorials targeting beginners can be valuable, but remember that Python’s official documentation is generally excellent, and it should be your first destination when you have questions.\nhttps://docs.Python.org/3/\nhttps://docs.Python.org/3/library/index.html\nTo learn Python more fully, the built-in official tutorial is also excellent and comprehensive (but does require a time commitment to get value out of it) https://docs.Python.org/3/tutorial/index.html\nFinally, don’t forget to solidify your understanding by conducting small experiments at the reticulate::repl_python().\nThank you for reading!"
  },
  {
    "objectID": "reticulate/doc/versions.html",
    "href": "reticulate/doc/versions.html",
    "title": "Python Version Configuration",
    "section": "",
    "text": "It is not uncommon for several installations of Python to be available on a given system. The reticulate package can bind to almost any Python installations, and provides a variety of convenient ways to allow the user to implicitly or explicitly specify which Python installation to select.\nNote that for reticulate to bind to a version of Python it must have been compiled with shared library support (i.e. with the --enable-shared flag).\nConsider the following code:\n\nlibrary(reticulate)\npy_eval(\"1+1\")\n\nIn this case, reticulate will search for a suitable Python installation. In the absence of other hints (detailed below), reticulate will fallback to an environment named “r-reticulate”, creating it if necessary.\nConsider another case:\n\nlibrary(reticulate)\nscipy &lt;- import(\"scipy\")\nscipy$amin(c(1,3,5,7))\n\nIn this case, reticulate will first look for an environment named “r-scipy”, and if that doesn’t exist, it will fallback to the environment named “r-reticulate”."
  },
  {
    "objectID": "reticulate/doc/versions.html#locating-python",
    "href": "reticulate/doc/versions.html#locating-python",
    "title": "Python Version Configuration",
    "section": "",
    "text": "It is not uncommon for several installations of Python to be available on a given system. The reticulate package can bind to almost any Python installations, and provides a variety of convenient ways to allow the user to implicitly or explicitly specify which Python installation to select.\nNote that for reticulate to bind to a version of Python it must have been compiled with shared library support (i.e. with the --enable-shared flag).\nConsider the following code:\n\nlibrary(reticulate)\npy_eval(\"1+1\")\n\nIn this case, reticulate will search for a suitable Python installation. In the absence of other hints (detailed below), reticulate will fallback to an environment named “r-reticulate”, creating it if necessary.\nConsider another case:\n\nlibrary(reticulate)\nscipy &lt;- import(\"scipy\")\nscipy$amin(c(1,3,5,7))\n\nIn this case, reticulate will first look for an environment named “r-scipy”, and if that doesn’t exist, it will fallback to the environment named “r-reticulate”."
  },
  {
    "objectID": "reticulate/doc/versions.html#providing-hints",
    "href": "reticulate/doc/versions.html#providing-hints",
    "title": "Python Version Configuration",
    "section": "Providing Hints",
    "text": "Providing Hints\nThere are a few ways you can provide hints as to which version of Python should be used:\n\nBy setting the value of the RETICULATE_PYTHON environment variable to a Python binary. Note that if you set this environment variable, then the specified version of Python will always be used (i.e. this is prescriptive rather than advisory). To set the value of RETICULATE_PYTHON, insert Sys.setenv(RETICULATE_PYTHON = PATH) into your project’s .Rprofile, where PATH is your preferred Python binary.\nBy calling one of the these functions:\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nuse_python()\nSpecify the path a specific Python binary.\n\n\nuse_virtualenv()\nSpecify the name of (or path to) a Python virtualenv.\n\n\nuse_condaenv()\nSpecify the name of a Conda environment.\n\n\n\nFor example:\n\nlibrary(reticulate)\nuse_python(\"/usr/local/bin/python\")\nuse_virtualenv(\"~/myenv\")\nuse_condaenv(\"myenv\")\n\nIf the use_virtualenv() function is supplied a name of a virtual environment (as opposed to a path), it will look in the virtualenv root directory, by default ~/.virtualenvs, and configurable by setting the environment variable WORKON_HOME.\nThe use_condaenv() function will use whatever conda binary is found on the PATH. If you want to use a specific alternate version you can use the conda parameter. For example:\n\nuse_condaenv(condaenv = \"r-nlp\", conda = \"/opt/anaconda3/bin/conda\")\n\nNote that the use_*() functions take an optional required argument. By default, a value of required = NULL is equivalent to required = TRUE in most circumstances. If required = FALSE is supplied, then the call is considered an optional hint as to where to find Python (i.e. it doesn’t produce an error if the specified version doesn’t exist)."
  },
  {
    "objectID": "reticulate/doc/versions.html#order-of-discovery",
    "href": "reticulate/doc/versions.html#order-of-discovery",
    "title": "Python Version Configuration",
    "section": "Order of Discovery",
    "text": "Order of Discovery\nThe order in which Python installation will be discovered and used is as follows:\n\nIf specified, the location referenced by the RETICULATE_PYTHON environment variable. (Path to a Python binary)\nIf specified, the location referenced by the RETICULATE_PYTHON_ENV environment variable. (Path to or name of a virtual environment or conda environment)\nIf specified, the location referenced by calls to use_python(), use_virtualenv(), and use_condaenv() with required = TRUE (the default).\nIf the environment variable VIRTUAL_ENV is defined (typically from running an activate script before R started, or from having the “Automatically activate project-local Python environments” option enabled in the RStudio IDE), then the Python from the activated environment is used.\nIf the current working directory contains a pyproject.toml file from a poetry environment, the Python installation from the poetry environment is used.\nIf the current working directory contains a Pipfile associated with a pipenv, the Python installation from pipenv is used.\nIf the current working directory contains a directory named “venv”, “virtualenv”, “.venv”, or “.virtualenv”, and that directory is a Python virtual environment, the Python from the virtual environment is used.\nIf there was a call (typically from within a package using reticulate), of the form: import(\"bar\", delay_load = list(environment = \"r-barlyr\"), and there exists a virtual environment or conda environment named \"r-barlyr\", it is used.\nIf any call to use_python(), use_virtualenv(), or use_condaenv() was made with required = FALSE, or from within a packages .onLoad() function, and the referenced python installation exists, it is used.\nIf there was a call to import(\"bar\"), and there exists a virtual environment or conda environment named \"r-bar\", it is used.\nIf specified, the location referenced by the RETICULATE_PYTHON_FALLBACK environment variable. (Path to a python binary)\nIn the absence of any expression of preference via one of the ways outlined above, reticulate falls back to using a virtual environment named \"r-reticulate\". If one does not exist, reticulate will offer to create one.\nIf the “r-reticulate” environment is not available and cannot be created, then we fall back to using the Python on the PATH, or on Windows, the Python referenced by the registry. If both python and python3 are on the PATH, then reticulate will prefer python3, unless only python has NumPy installed, or python3 is built for a different architecture than R (e.g., x86)."
  },
  {
    "objectID": "reticulate/doc/versions.html#python-packages",
    "href": "reticulate/doc/versions.html#python-packages",
    "title": "Python Version Configuration",
    "section": "Python Packages",
    "text": "Python Packages\nYou can learn more about installing Python packages into virtualenvs or Conda environments in the article on Installing Python Packages."
  },
  {
    "objectID": "reticulate/doc/versions.html#configuration-info",
    "href": "reticulate/doc/versions.html#configuration-info",
    "title": "Python Version Configuration",
    "section": "Configuration Info",
    "text": "Configuration Info\nYou can use the py_config() function to query for information about the specific version of Python in use as well as a list of other Python versions discovered on the system:\n\npy_config()\n\nYou can also use the py_discover_config() function to see what version of Python will be used without actually loading Python:\n\npy_discover_config()"
  }
]